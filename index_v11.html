<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 翻转墙 - 金属质感 v11</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #eee;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            z-index: 10;
        }

        canvas {
            display: block;
        }

        #gui-container {
            position: fixed;
            top: 8px;
            right: 8px;
            max-height: calc(100vh - 16px);
            overflow-y: auto;
            z-index: 9999;
            pointer-events: auto;
        }

        #gui-container .dg.main {
            margin-top: 0 !important;
        }

        #settings-toggle {
            position: fixed;
            right: 16px;
            bottom: 16px;
            z-index: 10001;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(12, 16, 22, 0.88);
            color: #e7edf7;
            padding: 10px 14px;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(6px);
        }

        #settings-toggle:hover {
            background: rgba(22, 28, 38, 0.95);
        }
    </style>
</head>

<body>
    <div id="ui">
        <h2>3D 像素翻转墙 v11</h2>
        <p>左键旋转 | 右键平移 | 滚轮缩放</p>
        <p>鼠标划过像素触发 120 度翻转（金属质感 + 低彩反射）</p>
    </div>
    <div id="gui-container"></div>
    <button id="settings-toggle" type="button">收起设置</button>

    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- dat.GUI -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script>
        if (typeof dat === 'undefined') {
            document.write('<script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"><\\/script>');
        }
    </script>

    <script>
        let scene, camera, renderer, raycaster, mouse, controls;
        let spotLight, fillLight, rimLight, backLight;
        let isCameraInteracting = false;
        const pixels = []; // Stores the prism groups
        const DEFAULT_ROWS = 12;
        const DEFAULT_COLS = 22;
        const DEFAULT_GAP = 0.057;

        // 默认：金属灰 + 翻转金色。高光条避免纯白，防止面片被冲成白块
        const BASE_MATERIAL_PARAMS = {
            roughness: 0.11,
            metalness: 1.0,
            clearcoat: 1.0,
            clearcoatRoughness: 0.02,
            envMapIntensity: 4.2
        };

        const BASE_FACE_COLOR_PARAMS = {
            globalSeparation: 1.28,

            color1: '#98a3b3',
            hueShift1: -0.015,
            saturation1: 0.55,
            lightness1: 1.05,

            color2: '#6f7b8a',
            hueShift2: -0.01,
            saturation2: 0.62,
            lightness2: 0.86,

            color3: '#d5a85c',
            hueShift3: 0.01,
            saturation3: 1.26,
            lightness3: 0.95
        };

        const BASE_ENV_PARAMS = {
            bgTop: '#151518',
            bgMid: '#10161f',
            bgBottom: '#1d232e',

            strip1X: 80,
            strip1Width: 100,
            strip1Alpha: 0.56,
            strip1Top: '#c6cfdb',
            strip1Bottom: '#7f8da2',

            strip2X: 320,
            strip2Width: 120,
            strip2Alpha: 0.48,
            strip2Top: '#b4c0d0',
            strip2Bottom: '#6f7e93',

            strip3X: 640,
            strip3Width: 130,
            strip3Alpha: 0.42,
            strip3Top: '#b4a483',
            strip3Bottom: '#776846',

            block1Enabled: true,
            block1X: 240,
            block1Y: 278,
            block1Width: 340,
            block1Height: 86,
            block1Start: '#6d7fa8',
            block1End: '#435270',
            block1Alpha: 0.16,

            block2Enabled: true,
            block2X: 96,
            block2Y: 118,
            block2Width: 220,
            block2Height: 58,
            block2Start: '#98a7bd',
            block2End: '#606b7e',
            block2Alpha: 0.1,

            sparkleCount: 14,
            sparkleSize: 5,
            sparkleAlpha: 0.32
        };

        const materialParams = { ...BASE_MATERIAL_PARAMS };
        const faceColorParams = { ...BASE_FACE_COLOR_PARAMS };
        const envParams = { ...BASE_ENV_PARAMS };

        const DEFAULT_COLOR_PRESETS = {
            '金属灰翻转金色': {},
            '春节纯洁红': {
                materialParams: {
                    roughness: 0.09,
                    envMapIntensity: 3.9
                },
                faceColorParams: {
                    globalSeparation: 1.42,
                    color1: '#d11533',
                    hueShift1: 0.0,
                    saturation1: 1.45,
                    lightness1: 0.95,
                    color2: '#f1c35c',
                    hueShift2: -0.01,
                    saturation2: 1.28,
                    lightness2: 1.02,
                    color3: '#7f0019',
                    hueShift3: 0.01,
                    saturation3: 1.32,
                    lightness3: 0.78
                },
                envParams: {
                    bgTop: '#1a080a',
                    bgMid: '#2b0b0f',
                    bgBottom: '#120608',
                    strip1Top: '#e7c78b',
                    strip1Bottom: '#b98a43',
                    strip1Alpha: 0.46,
                    strip2Top: '#d15f6f',
                    strip2Bottom: '#8f2335',
                    strip2Alpha: 0.5,
                    strip3Top: '#dfb76c',
                    strip3Bottom: '#926019',
                    strip3Alpha: 0.42,
                    block1Start: '#a60f2d',
                    block1End: '#5d0718',
                    block1Alpha: 0.2,
                    block2Start: '#f0bc5f',
                    block2End: '#96601d',
                    block2Alpha: 0.13,
                    sparkleCount: 18,
                    sparkleAlpha: 0.38
                }
            },
            '钛蓝冷光': {
                materialParams: {
                    roughness: 0.08,
                    envMapIntensity: 4.5
                },
                faceColorParams: {
                    globalSeparation: 1.3,
                    color1: '#c0cddd',
                    hueShift1: -0.02,
                    saturation1: 0.75,
                    lightness1: 1.08,
                    color2: '#6f8fb8',
                    hueShift2: -0.04,
                    saturation2: 1.2,
                    lightness2: 0.92,
                    color3: '#8dc8d8',
                    hueShift3: 0.015,
                    saturation3: 1.02,
                    lightness3: 0.95
                },
                envParams: {
                    bgTop: '#0c1018',
                    bgMid: '#101a2b',
                    bgBottom: '#0b121f',
                    strip1Top: '#b8c6da',
                    strip1Bottom: '#6f85a4',
                    strip2Top: '#9eb6d8',
                    strip2Bottom: '#4f6c95',
                    strip3Top: '#a5c7d3',
                    strip3Bottom: '#4f7d8f',
                    block1Start: '#4f6e9b',
                    block1End: '#30435f',
                    block1Alpha: 0.2,
                    block2Start: '#85a8c9',
                    block2End: '#4a6481',
                    block2Alpha: 0.11
                }
            },
            '墨黑铬面': {
                materialParams: {
                    roughness: 0.14,
                    clearcoat: 0.9,
                    envMapIntensity: 3.2
                },
                faceColorParams: {
                    globalSeparation: 1.18,
                    color1: '#4a505a',
                    hueShift1: -0.015,
                    saturation1: 0.6,
                    lightness1: 0.78,
                    color2: '#262b34',
                    hueShift2: 0.0,
                    saturation2: 0.85,
                    lightness2: 0.7,
                    color3: '#9ea8b7',
                    hueShift3: 0.0,
                    saturation3: 0.7,
                    lightness3: 0.9
                },
                envParams: {
                    bgTop: '#0a0a0b',
                    bgMid: '#11151b',
                    bgBottom: '#090b0f',
                    strip1Top: '#aab3c0',
                    strip1Bottom: '#606c7e',
                    strip1Alpha: 0.42,
                    strip2Top: '#8f9cab',
                    strip2Bottom: '#4b5567',
                    strip2Alpha: 0.38,
                    strip3Top: '#adb6c4',
                    strip3Bottom: '#687486',
                    strip3Alpha: 0.34,
                    block1Start: '#44506a',
                    block1End: '#2a3342',
                    block1Alpha: 0.12,
                    block2Alpha: 0.06,
                    sparkleCount: 10,
                    sparkleAlpha: 0.24
                }
            },
            '翡翠鎏金': {
                materialParams: {
                    roughness: 0.1,
                    envMapIntensity: 4.0
                },
                faceColorParams: {
                    globalSeparation: 1.34,
                    color1: '#2f7f66',
                    hueShift1: -0.02,
                    saturation1: 1.2,
                    lightness1: 0.9,
                    color2: '#d9b25e',
                    hueShift2: 0.0,
                    saturation2: 1.22,
                    lightness2: 1.0,
                    color3: '#0f4f3f',
                    hueShift3: 0.01,
                    saturation3: 1.15,
                    lightness3: 0.78
                },
                envParams: {
                    bgTop: '#081412',
                    bgMid: '#0f2420',
                    bgBottom: '#07110f',
                    strip1Top: '#b7d1c5',
                    strip1Bottom: '#628f7d',
                    strip2Top: '#d0bc8f',
                    strip2Bottom: '#9a7b43',
                    strip3Top: '#95c0ac',
                    strip3Bottom: '#4f7e6d',
                    block1Start: '#3a8a71',
                    block1End: '#1d4f40',
                    block1Alpha: 0.2,
                    block2Start: '#c7a766',
                    block2End: '#6f5528',
                    block2Alpha: 0.11
                }
            },
            '暮色玫瑰铜': {
                materialParams: {
                    roughness: 0.085,
                    envMapIntensity: 4.1
                },
                faceColorParams: {
                    globalSeparation: 1.32,
                    color1: '#b88497',
                    hueShift1: -0.01,
                    saturation1: 1.1,
                    lightness1: 0.97,
                    color2: '#cf8c63',
                    hueShift2: 0.02,
                    saturation2: 1.22,
                    lightness2: 0.95,
                    color3: '#5f3f4f',
                    hueShift3: 0.0,
                    saturation3: 1.15,
                    lightness3: 0.8
                },
                envParams: {
                    bgTop: '#170d15',
                    bgMid: '#25121d',
                    bgBottom: '#120911',
                    strip1Top: '#d2a8ba',
                    strip1Bottom: '#8f687c',
                    strip2Top: '#c79a88',
                    strip2Bottom: '#875e4f',
                    strip3Top: '#bba6c6',
                    strip3Bottom: '#6e5879',
                    block1Start: '#935b75',
                    block1End: '#57344a',
                    block1Alpha: 0.2,
                    block2Start: '#c58f67',
                    block2End: '#6f4b33',
                    block2Alpha: 0.12
                }
            }
        };

        const presetState = {
            theme: '金属灰翻转金色'
        };

        const PRESET_STORAGE_KEY = 'flip_wall_v11_presets';

        const displayConfig = {
            sequence: '10|9|8|7|6|5|4|3|2|1|HELLO|WORLD|你好|新年快乐',
            intervalMs: 1200,
            onFace: 2,
            threshold: 120,
            textScale: 0.78,
            bold: true,
            compactCols: 10,
            autoExpand: true,
            loop: true
        };

        const playbackState = {
            running: false,
            runId: 0,
            lastText: ''
        };

        const FONT_HEIGHT = 7;
        const FONT_SPACING = 1;
        const PIXEL_FONT = {
            '0': ['01110', '10001', '10011', '10101', '11001', '10001', '01110'],
            '1': ['00100', '01100', '00100', '00100', '00100', '00100', '01110'],
            '2': ['01110', '10001', '00001', '00010', '00100', '01000', '11111'],
            '3': ['01110', '10001', '00001', '00110', '00001', '10001', '01110'],
            '4': ['00010', '00110', '01010', '10010', '11111', '00010', '00010'],
            '5': ['11111', '10000', '11110', '00001', '00001', '10001', '01110'],
            '6': ['00110', '01000', '10000', '11110', '10001', '10001', '01110'],
            '7': ['11111', '00001', '00010', '00100', '01000', '01000', '01000'],
            '8': ['01110', '10001', '10001', '01110', '10001', '10001', '01110'],
            '9': ['01110', '10001', '10001', '01111', '00001', '00010', '01100'],
            'A': ['01110', '10001', '10001', '11111', '10001', '10001', '10001'],
            'B': ['11110', '10001', '10001', '11110', '10001', '10001', '11110'],
            'C': ['01110', '10001', '10000', '10000', '10000', '10001', '01110'],
            'D': ['11110', '10001', '10001', '10001', '10001', '10001', '11110'],
            'E': ['11111', '10000', '10000', '11110', '10000', '10000', '11111'],
            'F': ['11111', '10000', '10000', '11110', '10000', '10000', '10000'],
            'G': ['01110', '10001', '10000', '10111', '10001', '10001', '01110'],
            'H': ['10001', '10001', '10001', '11111', '10001', '10001', '10001'],
            'I': ['01110', '00100', '00100', '00100', '00100', '00100', '01110'],
            'J': ['00001', '00001', '00001', '00001', '10001', '10001', '01110'],
            'K': ['10001', '10010', '10100', '11000', '10100', '10010', '10001'],
            'L': ['10000', '10000', '10000', '10000', '10000', '10000', '11111'],
            'M': ['10001', '11011', '10101', '10001', '10001', '10001', '10001'],
            'N': ['10001', '11001', '10101', '10011', '10001', '10001', '10001'],
            'O': ['01110', '10001', '10001', '10001', '10001', '10001', '01110'],
            'P': ['11110', '10001', '10001', '11110', '10000', '10000', '10000'],
            'Q': ['01110', '10001', '10001', '10001', '10101', '10010', '01101'],
            'R': ['11110', '10001', '10001', '11110', '10100', '10010', '10001'],
            'S': ['01111', '10000', '10000', '01110', '00001', '00001', '11110'],
            'T': ['11111', '00100', '00100', '00100', '00100', '00100', '00100'],
            'U': ['10001', '10001', '10001', '10001', '10001', '10001', '01110'],
            'V': ['10001', '10001', '10001', '10001', '10001', '01010', '00100'],
            'W': ['10001', '10001', '10001', '10001', '10101', '10101', '01010'],
            'X': ['10001', '10001', '01010', '00100', '01010', '10001', '10001'],
            'Y': ['10001', '10001', '01010', '00100', '00100', '00100', '00100'],
            'Z': ['11111', '00001', '00010', '00100', '01000', '10000', '11111'],
            ' ': ['00000', '00000', '00000', '00000', '00000', '00000', '00000']
        };

        const panelState = {
            visible: true
        };

        // Constants from prism_v2.html adjustment
        const UNIT_SIZE = 1.0;
        const PLATE_THICKNESS = 0.001;
        const BEVEL_THICKNESS = 0.001;
        const CORNER_RADIUS = 0.3;
        const GAP_OFFSET = 0.0;
        const PLATE_SCALE = 1.0;

        const innerParams = {
            size: 0.54,
            length: 0.84,
            radius: 0.05,
            bevel: 0.0,
            color: '#111111',
            x: 0,
            y: 0,
            z: 0
        };

        // 初始配置
        const config = {
            initRotationX: Math.PI / 2, // 90度，让面完全垂直
            initRotationY: 0.0,
            initRotationZ: 0.0,
            gap: DEFAULT_GAP,
            gridRows: DEFAULT_ROWS,
            gridCols: DEFAULT_COLS,

            // 相机设置
            camX: 0, camY: 0, camZ: 33,
            camFov: 32,


            // 灯光设置 (聚光灯)
            spotLightX: 7, spotLightY: 12, spotLightZ: 28,
            spotLightIntensity: 1.8,
            spotLightAngle: Math.PI / 4, // 45度
            spotLightPenumbra: 0.5, // 边缘柔化

            fillLightX: -10, fillLightY: 3, fillLightZ: 18,
            fillLightIntensity: 0.55
        };

        // Shared Geometry and Material (for performance)
        let plateGeometry, innerGeometry;
        let materials = [];
        let innerMaterial;
        let guiPanel = null;
        let colorPresets = {};
        let generatedEnvMap = null;
        let envRebuildTimer = null;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101317);

            // 透视相机（更有纵深和透视感）
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(config.camFov, aspect, 0.1, 1000);
            camera.position.set(config.camX, config.camY, config.camZ);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3;
            renderer.shadowMap.enabled = true; // Enable shadows if needed
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.06;
            controls.enablePan = true;
            controls.screenSpacePanning = true;
            controls.minDistance = 10;
            controls.maxDistance = 90;
            controls.target.set(0, 0, 0);
            controls.addEventListener('start', () => {
                isCameraInteracting = true;
            });
            controls.addEventListener('end', () => {
                isCameraInteracting = false;
            });

            // Lighting from prism_v2 + prism_v3 metallic tuning
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.16);
            scene.add(ambientLight);

            // 主光源：改用 SpotLight 以获得柔和边缘和圆形光照
            spotLight = new THREE.SpotLight(0xffffff, config.spotLightIntensity);
            spotLight.position.set(config.spotLightX, config.spotLightY, config.spotLightZ);
            spotLight.angle = config.spotLightAngle;
            spotLight.penumbra = config.spotLightPenumbra; // 关键：让边缘柔和
            spotLight.decay = 1.5; // 物理衰减
            spotLight.distance = 100;

            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 2048; // 提高阴影质量
            spotLight.shadow.mapSize.height = 2048;
            spotLight.shadow.bias = -0.0001;
            scene.add(spotLight);

            fillLight = new THREE.DirectionalLight(0xe3ebf8, config.fillLightIntensity);
            fillLight.position.set(config.fillLightX, config.fillLightY, config.fillLightZ);
            scene.add(fillLight);

            rimLight = new THREE.DirectionalLight(0xf7f9ff, 0.6);
            rimLight.position.set(-12, -6, 10);
            scene.add(rimLight);

            backLight = new THREE.DirectionalLight(0xdde6f7, 0.35);
            backLight.position.set(0, -5, -15);
            scene.add(backLight);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2(-1, -1);
            colorPresets = loadColorPresets();

            // Pre-create geometries and materials
            initResources();
            applyPreset(presetState.theme);
            createPixelWall();
            setupSettingsToggle();
            setPanelVisible(true);

            initGUI();

            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function scheduleEnvironmentRebuild() {
            clearTimeout(envRebuildTimer);
            envRebuildTimer = setTimeout(loadEnvironment, 30);
        }

        function loadEnvironment() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();

            const nextEnvMap = createMetalEnvironment(pmremGenerator);
            pmremGenerator.dispose();

            if (generatedEnvMap) {
                generatedEnvMap.dispose();
            }

            generatedEnvMap = nextEnvMap;
            scene.environment = generatedEnvMap;
            refreshMaterialEnvironment();
        }

        function hexToRgb(hex) {
            let value = (hex || '#ffffff').replace('#', '').trim();
            if (value.length === 3) {
                value = value.split('').map(c => c + c).join('');
            }
            const intVal = parseInt(value, 16);
            return {
                r: (intVal >> 16) & 255,
                g: (intVal >> 8) & 255,
                b: intVal & 255
            };
        }

        function toRgba(hex, alpha) {
            const { r, g, b } = hexToRgb(hex);
            return `rgba(${r}, ${g}, ${b}, ${Math.max(0, Math.min(alpha, 1))})`;
        }

        function pseudoRandom(seed) {
            const x = Math.sin(seed * 12.9898) * 43758.5453123;
            return x - Math.floor(x);
        }

        function drawHighlightStrip(ctx, strip, canvasHeight) {
            const width = Math.max(1, strip.width);
            const alpha = Math.max(0, Math.min(strip.alpha, 1));
            const x = strip.x;

            const horizontal = ctx.createLinearGradient(x, 0, x + width, 0);
            horizontal.addColorStop(0.0, toRgba(strip.top, 0.0));
            horizontal.addColorStop(0.2, toRgba(strip.top, alpha * 0.75));
            horizontal.addColorStop(0.5, toRgba(strip.bottom, alpha));
            horizontal.addColorStop(0.8, toRgba(strip.top, alpha * 0.75));
            horizontal.addColorStop(1.0, toRgba(strip.top, 0.0));
            ctx.fillStyle = horizontal;
            ctx.fillRect(x, 0, width, canvasHeight);

            const verticalTint = ctx.createLinearGradient(0, 0, 0, canvasHeight);
            verticalTint.addColorStop(0.0, toRgba(strip.top, alpha * 0.55));
            verticalTint.addColorStop(1.0, toRgba(strip.bottom, alpha * 0.55));
            ctx.globalAlpha = 0.35;
            ctx.fillStyle = verticalTint;
            ctx.fillRect(x, 0, width, canvasHeight);
            ctx.globalAlpha = 1.0;
        }

        function drawTintBlock(ctx, block) {
            if (!block.enabled) {
                return;
            }

            const grad = ctx.createLinearGradient(block.x, block.y, block.x + block.width, block.y + block.height);
            grad.addColorStop(0.0, toRgba(block.start, 0.0));
            grad.addColorStop(0.2, toRgba(block.start, block.alpha));
            grad.addColorStop(0.8, toRgba(block.end, block.alpha));
            grad.addColorStop(1.0, toRgba(block.end, 0.0));
            ctx.fillStyle = grad;
            ctx.fillRect(block.x, block.y, block.width, block.height);
        }

        function createMetalEnvironment(pmremGenerator) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            const bg = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bg.addColorStop(0.0, envParams.bgTop);
            bg.addColorStop(0.5, envParams.bgMid);
            bg.addColorStop(1.0, envParams.bgBottom);
            ctx.fillStyle = bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawHighlightStrip(ctx, {
                x: envParams.strip1X,
                width: envParams.strip1Width,
                alpha: envParams.strip1Alpha,
                top: envParams.strip1Top,
                bottom: envParams.strip1Bottom
            }, canvas.height);
            drawHighlightStrip(ctx, {
                x: envParams.strip2X,
                width: envParams.strip2Width,
                alpha: envParams.strip2Alpha,
                top: envParams.strip2Top,
                bottom: envParams.strip2Bottom
            }, canvas.height);
            drawHighlightStrip(ctx, {
                x: envParams.strip3X,
                width: envParams.strip3Width,
                alpha: envParams.strip3Alpha,
                top: envParams.strip3Top,
                bottom: envParams.strip3Bottom
            }, canvas.height);

            drawTintBlock(ctx, {
                enabled: envParams.block1Enabled,
                x: envParams.block1X,
                y: envParams.block1Y,
                width: envParams.block1Width,
                height: envParams.block1Height,
                start: envParams.block1Start,
                end: envParams.block1End,
                alpha: envParams.block1Alpha
            });
            drawTintBlock(ctx, {
                enabled: envParams.block2Enabled,
                x: envParams.block2X,
                y: envParams.block2Y,
                width: envParams.block2Width,
                height: envParams.block2Height,
                start: envParams.block2Start,
                end: envParams.block2End,
                alpha: envParams.block2Alpha
            });

            for (let i = 0; i < envParams.sparkleCount; i++) {
                const x = pseudoRandom(i * 7 + 3) * canvas.width;
                const y = pseudoRandom(i * 11 + 5) * canvas.height;
                const size = Math.max(1.2, pseudoRandom(i * 13 + 7) * envParams.sparkleSize);
                const alpha = envParams.sparkleAlpha * (0.45 + pseudoRandom(i * 17 + 9) * 0.55);
                ctx.globalAlpha = Math.min(alpha, 1.0);
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            const texture = new THREE.CanvasTexture(canvas);
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.encoding = THREE.sRGBEncoding;

            const envMap = pmremGenerator.fromEquirectangular(texture).texture;
            texture.dispose();
            return envMap;
        }

        function refreshMaterialEnvironment() {
            materials.forEach((material) => {
                material.needsUpdate = true;
            });
            if (innerMaterial) {
                innerMaterial.needsUpdate = true;
            }
        }

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function wrapHue(value) {
            return ((value % 1) + 1) % 1;
        }

        function buildFaceColor(index) {
            const base = new THREE.Color(faceColorParams['color' + index]);
            const hsl = { h: 0, s: 0, l: 0 };
            base.getHSL(hsl);

            const hueShift = faceColorParams['hueShift' + index];
            const satMul = faceColorParams['saturation' + index];
            const lightMul = faceColorParams['lightness' + index];
            const separation = faceColorParams.globalSeparation;

            const h = wrapHue(hsl.h + hueShift);
            const s = clamp(hsl.s * satMul * separation, 0, 1);
            const lRaw = clamp(hsl.l * lightMul, 0, 1);
            const l = clamp(0.5 + (lRaw - 0.5) * separation, 0, 1);

            return new THREE.Color().setHSL(h, s, l);
        }

        function updateFaceMaterials() {
            if (!materials || materials.length < 3) {
                return;
            }

            for (let i = 0; i < 3; i++) {
                materials[i].color.copy(buildFaceColor(i + 1));
                materials[i].needsUpdate = true;
            }
        }

        function assignKnown(target, values) {
            if (!values) {
                return;
            }
            Object.keys(values).forEach((key) => {
                if (Object.prototype.hasOwnProperty.call(target, key)) {
                    target[key] = values[key];
                }
            });
        }

        function deepClone(value) {
            return JSON.parse(JSON.stringify(value));
        }

        function deepMerge(base, override) {
            const result = deepClone(base);
            if (!override || typeof override !== 'object') {
                return result;
            }
            Object.keys(override).forEach((key) => {
                const source = override[key];
                if (
                    source &&
                    typeof source === 'object' &&
                    !Array.isArray(source) &&
                    result[key] &&
                    typeof result[key] === 'object' &&
                    !Array.isArray(result[key])
                ) {
                    result[key] = deepMerge(result[key], source);
                } else {
                    result[key] = source;
                }
            });
            return result;
        }

        function loadColorPresets() {
            const presets = deepClone(DEFAULT_COLOR_PRESETS);
            try {
                const raw = localStorage.getItem(PRESET_STORAGE_KEY);
                if (!raw) return presets;
                const stored = JSON.parse(raw);
                if (!stored || typeof stored !== 'object') return presets;
                Object.keys(stored).forEach((name) => {
                    if (presets[name]) {
                        presets[name] = deepMerge(presets[name], stored[name]);
                    }
                });
                return presets;
            } catch (error) {
                console.warn('读取本地模板失败，将使用默认模板', error);
                return presets;
            }
        }

        function persistColorPresets() {
            try {
                localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(colorPresets));
            } catch (error) {
                console.warn('保存本地模板失败', error);
            }
        }

        function snapshotCurrentPreset() {
            return {
                materialParams: deepClone(materialParams),
                faceColorParams: deepClone(faceColorParams),
                envParams: deepClone(envParams)
            };
        }

        function saveCurrentPreset() {
            const name = presetState.theme;
            colorPresets[name] = snapshotCurrentPreset();
            persistColorPresets();
        }

        function restoreCurrentPresetDefault() {
            const name = presetState.theme;
            colorPresets[name] = deepClone(DEFAULT_COLOR_PRESETS[name] || {});
            persistColorPresets();
            applyPreset(name);
        }

        function updateGuiFolderDisplay(folder) {
            if (!folder) {
                return;
            }

            if (Array.isArray(folder.__controllers)) {
                folder.__controllers.forEach((controller) => controller.updateDisplay());
            }

            if (folder.__folders) {
                Object.values(folder.__folders).forEach(updateGuiFolderDisplay);
            }
        }

        function applyPreset(themeName) {
            const fallbackName = Object.keys(colorPresets)[0] || '金属灰翻转金色';
            const resolvedName = colorPresets[themeName] ? themeName : fallbackName;
            const preset = colorPresets[resolvedName] || {};

            assignKnown(materialParams, BASE_MATERIAL_PARAMS);
            assignKnown(faceColorParams, BASE_FACE_COLOR_PARAMS);
            assignKnown(envParams, BASE_ENV_PARAMS);

            assignKnown(materialParams, preset.materialParams);
            assignKnown(faceColorParams, preset.faceColorParams);
            assignKnown(envParams, preset.envParams);

            presetState.theme = resolvedName;

            updateFaceMaterials();
            updateMetalMaterials();

            if (renderer) {
                loadEnvironment();
            }

            if (guiPanel) {
                updateGuiFolderDisplay(guiPanel);
            }
        }

        function setPanelVisible(visible) {
            panelState.visible = !!visible;
            const uiEl = document.getElementById('ui');
            const guiEl = document.getElementById('gui-container');
            const toggleBtn = document.getElementById('settings-toggle');

            if (uiEl) {
                uiEl.style.display = panelState.visible ? 'block' : 'none';
            }
            if (guiEl) {
                guiEl.style.display = panelState.visible ? 'block' : 'none';
            }
            if (toggleBtn) {
                toggleBtn.textContent = panelState.visible ? '收起设置' : '打开设置';
            }
        }

        function setupSettingsToggle() {
            const toggleBtn = document.getElementById('settings-toggle');
            if (!toggleBtn || toggleBtn.dataset.bound === '1') {
                return;
            }
            toggleBtn.dataset.bound = '1';
            toggleBtn.addEventListener('click', () => {
                setPanelVisible(!panelState.visible);
            });
        }

        function initGUI() {
            if (typeof dat === 'undefined' || !dat.GUI) {
                console.warn('dat.GUI 未加载，跳过控制面板初始化');
                return;
            }

            const gui = new dat.GUI({ autoPlace: false, width: 330 });
            guiPanel = gui;
            const guiContainer = document.getElementById('gui-container');
            if (guiContainer) {
                guiContainer.innerHTML = '';
                guiContainer.appendChild(gui.domElement);
            } else {
                document.body.appendChild(gui.domElement);
            }
            gui.domElement.style.position = 'static';
            gui.domElement.style.top = '0';
            gui.domElement.style.right = '0';
            gui.domElement.style.zIndex = '9999';
            gui.domElement.style.pointerEvents = 'auto';

            const presetFolder = gui.addFolder('配色模板');
            const presetOptions = Object.keys(colorPresets);
            presetFolder.add(presetState, 'theme', presetOptions).name('模板').onChange((value) => {
                applyPreset(value);
            });
            presetFolder.add({ applyNow: () => applyPreset(presetState.theme) }, 'applyNow').name('一键应用');
            presetFolder.add({ saveCurrent: () => saveCurrentPreset() }, 'saveCurrent').name('保存更改');
            presetFolder.add({ restoreDefault: () => restoreCurrentPresetDefault() }, 'restoreDefault').name('恢复默认');
            presetFolder.open();

            const playbackFolder = gui.addFolder('文字播放');
            playbackFolder.add(displayConfig, 'sequence').name('序列(|分隔)').onFinishChange((value) => {
                displayConfig.sequence = String(value || '');
            });
            playbackFolder.add(displayConfig, 'intervalMs', 200, 5000).step(50).name('切换间隔(ms)');
            playbackFolder.add(displayConfig, 'onFace', { 面1: 1, 面2: 2 }).name('显示面');
            playbackFolder.add(displayConfig, 'compactCols', 4, 40).step(1).name('紧凑列宽');
            playbackFolder.add(displayConfig, 'autoExpand').name('自动扩展列宽');
            playbackFolder.add(displayConfig, 'threshold', 20, 240).step(1).name('阈值');
            playbackFolder.add(displayConfig, 'textScale', 0.35, 1.0).step(0.01).name('字体缩放');
            playbackFolder.add(displayConfig, 'bold').name('粗体');
            playbackFolder.add(displayConfig, 'loop').name('循环播放');
            playbackFolder.add({ previewFirst: () => previewCurrentSequenceText() }, 'previewFirst').name('预览首项');
            playbackFolder.add({ playNow: () => { startPlayback(); } }, 'playNow').name('一键播放');
            playbackFolder.add({ stopNow: () => stopPlayback() }, 'stopNow').name('停止播放');

            const folder = gui.addFolder('初始角度调整');

            const updateRotations = () => {
                pixels.forEach(p => {
                    const face = Number.isFinite(p.userData.faceIndex) ? p.userData.faceIndex : 0;
                    p.userData.baseRotationX = config.initRotationX;
                    const targetX = config.initRotationX + face * ((Math.PI * 2) / 3);
                    p.rotation.set(targetX, config.initRotationY, config.initRotationZ);
                    p.userData.targetRotationX = targetX;
                    p.userData.isAnimating = false;
                });
            };

            const rebuildGrid = () => {
                config.gridRows = Math.max(1, Math.floor(config.gridRows));
                config.gridCols = Math.max(1, Math.floor(config.gridCols));
                createPixelWall();
            };

            folder.add(config, 'initRotationX', -Math.PI, Math.PI).step(0.01).name('X 轴角度').onChange(updateRotations);
            folder.add(config, 'initRotationY', -Math.PI, Math.PI).step(0.01).name('Y 轴角度').onChange(updateRotations);
            folder.add(config, 'gridRows', 1, 60).step(1).name('纵向像素').onFinishChange(rebuildGrid);
            folder.add(config, 'gridCols', 1, 120).step(1).name('横向像素').onFinishChange(rebuildGrid);
            folder.add(config, 'gap', 0.0, 0.5).step(0.001).name('行列间距').onChange(updatePositions);
            folder.open();

            // 相机设置面板
            const camFolder = gui.addFolder('相机视角设置');
            const updateCamera = () => {
                camera.position.set(config.camX, config.camY, config.camZ);
                controls.target.set(0, 0, 0);

                camera.fov = config.camFov;
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                controls.update();
            };
            camFolder.add(config, 'camX', -50, 50).name('位置 X').onChange(updateCamera);
            camFolder.add(config, 'camY', -50, 50).name('位置 Y').onChange(updateCamera);
            camFolder.add(config, 'camZ', 0, 100).name('位置 Z').onChange(updateCamera);
            camFolder.add(config, 'camFov', 18, 65).name('透视强度(FOV)').onChange(updateCamera);
            camFolder.open();

            // 灯光设置面板
            const lightFolder = gui.addFolder('光源设置');
            const updateLights = () => {
                spotLight.position.set(config.spotLightX, config.spotLightY, config.spotLightZ);
                spotLight.intensity = config.spotLightIntensity;
                spotLight.angle = config.spotLightAngle;
                spotLight.penumbra = config.spotLightPenumbra;

                fillLight.position.set(config.fillLightX, config.fillLightY, config.fillLightZ);
                fillLight.intensity = config.fillLightIntensity;
            };

            // 主光源 (SpotLight)
            lightFolder.add(config, 'spotLightX', -50, 50).name('主光 X').onChange(updateLights);
            lightFolder.add(config, 'spotLightY', -50, 50).name('主光 Y').onChange(updateLights);
            lightFolder.add(config, 'spotLightZ', 0, 100).name('主光 Z').onChange(updateLights);
            lightFolder.add(config, 'spotLightIntensity', 0, 4).name('主光强度').onChange(updateLights);
            lightFolder.add(config, 'spotLightAngle', 0, Math.PI / 2).name('光照角度').onChange(updateLights);
            lightFolder.add(config, 'spotLightPenumbra', 0, 1).name('边缘柔化').onChange(updateLights);

            // 补光 (Directional)
            lightFolder.add(config, 'fillLightX', -20, 20).name('补光 X').onChange(updateLights);
            lightFolder.add(config, 'fillLightY', -20, 20).name('补光 Y').onChange(updateLights);
            lightFolder.add(config, 'fillLightZ', -20, 20).name('补光 Z').onChange(updateLights);
            lightFolder.add(config, 'fillLightIntensity', 0, 2).name('补光强度').onChange(updateLights);

            const faceFolder = gui.addFolder('三面颜色');
            faceFolder.add(faceColorParams, 'globalSeparation', 0.8, 1.8).step(0.01).name('差异增强').onChange(updateFaceMaterials);

            const addFaceColorControls = (parentFolder, index, label) => {
                const section = parentFolder.addFolder(label);
                section.addColor(faceColorParams, 'color' + index).name('基色').onChange(updateFaceMaterials);
                section.add(faceColorParams, 'hueShift' + index, -0.2, 0.2).step(0.001).name('色相偏移').onChange(updateFaceMaterials);
                section.add(faceColorParams, 'saturation' + index, 0, 2).step(0.01).name('饱和度').onChange(updateFaceMaterials);
                section.add(faceColorParams, 'lightness' + index, 0.5, 1.5).step(0.01).name('明度').onChange(updateFaceMaterials);
            };

            addFaceColorControls(faceFolder, 1, '面 1');
            addFaceColorControls(faceFolder, 2, '面 2');
            addFaceColorControls(faceFolder, 3, '面 3');

            const metalFolder = gui.addFolder('金属材质');
            metalFolder.add(materialParams, 'roughness', 0.01, 0.2).name('粗糙度').onChange(updateMetalMaterials);
            metalFolder.add(materialParams, 'metalness', 0.7, 1).name('金属度').onChange(updateMetalMaterials);
            metalFolder.add(materialParams, 'clearcoat', 0.2, 1).name('清漆层').onChange(updateMetalMaterials);
            metalFolder.add(materialParams, 'clearcoatRoughness', 0.005, 0.12).name('清漆粗糙').onChange(updateMetalMaterials);
            metalFolder.add(materialParams, 'envMapIntensity', 1.2, 6).name('反射强度').onChange(updateMetalMaterials);

            const envFolder = gui.addFolder('反射环境');
            const bgFolder = envFolder.addFolder('背景渐变');
            bgFolder.addColor(envParams, 'bgTop').name('顶部色').onChange(scheduleEnvironmentRebuild);
            bgFolder.addColor(envParams, 'bgMid').name('中段色').onChange(scheduleEnvironmentRebuild);
            bgFolder.addColor(envParams, 'bgBottom').name('底部色').onChange(scheduleEnvironmentRebuild);

            const strip1Folder = envFolder.addFolder('高光条 1');
            strip1Folder.add(envParams, 'strip1X', 0, 1024).step(1).name('X').onChange(scheduleEnvironmentRebuild);
            strip1Folder.add(envParams, 'strip1Width', 10, 320).step(1).name('宽度').onChange(scheduleEnvironmentRebuild);
            strip1Folder.add(envParams, 'strip1Alpha', 0, 1).step(0.01).name('透明度').onChange(scheduleEnvironmentRebuild);
            strip1Folder.addColor(envParams, 'strip1Top').name('顶部色').onChange(scheduleEnvironmentRebuild);
            strip1Folder.addColor(envParams, 'strip1Bottom').name('底部色').onChange(scheduleEnvironmentRebuild);

            const strip2Folder = envFolder.addFolder('高光条 2');
            strip2Folder.add(envParams, 'strip2X', 0, 1024).step(1).name('X').onChange(scheduleEnvironmentRebuild);
            strip2Folder.add(envParams, 'strip2Width', 10, 320).step(1).name('宽度').onChange(scheduleEnvironmentRebuild);
            strip2Folder.add(envParams, 'strip2Alpha', 0, 1).step(0.01).name('透明度').onChange(scheduleEnvironmentRebuild);
            strip2Folder.addColor(envParams, 'strip2Top').name('顶部色').onChange(scheduleEnvironmentRebuild);
            strip2Folder.addColor(envParams, 'strip2Bottom').name('底部色').onChange(scheduleEnvironmentRebuild);

            const strip3Folder = envFolder.addFolder('高光条 3');
            strip3Folder.add(envParams, 'strip3X', 0, 1024).step(1).name('X').onChange(scheduleEnvironmentRebuild);
            strip3Folder.add(envParams, 'strip3Width', 10, 320).step(1).name('宽度').onChange(scheduleEnvironmentRebuild);
            strip3Folder.add(envParams, 'strip3Alpha', 0, 1).step(0.01).name('透明度').onChange(scheduleEnvironmentRebuild);
            strip3Folder.addColor(envParams, 'strip3Top').name('顶部色').onChange(scheduleEnvironmentRebuild);
            strip3Folder.addColor(envParams, 'strip3Bottom').name('底部色').onChange(scheduleEnvironmentRebuild);

            const block1Folder = envFolder.addFolder('色块 1 (靛蓝)');
            block1Folder.add(envParams, 'block1Enabled').name('启用').onChange(scheduleEnvironmentRebuild);
            block1Folder.add(envParams, 'block1X', 0, 1024).step(1).name('X').onChange(scheduleEnvironmentRebuild);
            block1Folder.add(envParams, 'block1Y', 0, 512).step(1).name('Y').onChange(scheduleEnvironmentRebuild);
            block1Folder.add(envParams, 'block1Width', 10, 600).step(1).name('宽度').onChange(scheduleEnvironmentRebuild);
            block1Folder.add(envParams, 'block1Height', 10, 250).step(1).name('高度').onChange(scheduleEnvironmentRebuild);
            block1Folder.add(envParams, 'block1Alpha', 0, 1).step(0.01).name('透明度').onChange(scheduleEnvironmentRebuild);
            block1Folder.addColor(envParams, 'block1Start').name('渐变起色').onChange(scheduleEnvironmentRebuild);
            block1Folder.addColor(envParams, 'block1End').name('渐变终色').onChange(scheduleEnvironmentRebuild);

            const block2Folder = envFolder.addFolder('色块 2');
            block2Folder.add(envParams, 'block2Enabled').name('启用').onChange(scheduleEnvironmentRebuild);
            block2Folder.add(envParams, 'block2X', 0, 1024).step(1).name('X').onChange(scheduleEnvironmentRebuild);
            block2Folder.add(envParams, 'block2Y', 0, 512).step(1).name('Y').onChange(scheduleEnvironmentRebuild);
            block2Folder.add(envParams, 'block2Width', 10, 600).step(1).name('宽度').onChange(scheduleEnvironmentRebuild);
            block2Folder.add(envParams, 'block2Height', 10, 250).step(1).name('高度').onChange(scheduleEnvironmentRebuild);
            block2Folder.add(envParams, 'block2Alpha', 0, 1).step(0.01).name('透明度').onChange(scheduleEnvironmentRebuild);
            block2Folder.addColor(envParams, 'block2Start').name('渐变起色').onChange(scheduleEnvironmentRebuild);
            block2Folder.addColor(envParams, 'block2End').name('渐变终色').onChange(scheduleEnvironmentRebuild);

            const sparkleFolder = envFolder.addFolder('亮点');
            sparkleFolder.add(envParams, 'sparkleCount', 0, 50).step(1).name('数量').onChange(scheduleEnvironmentRebuild);
            sparkleFolder.add(envParams, 'sparkleSize', 1, 12).step(0.1).name('尺寸').onChange(scheduleEnvironmentRebuild);
            sparkleFolder.add(envParams, 'sparkleAlpha', 0, 1).step(0.01).name('透明度').onChange(scheduleEnvironmentRebuild);
        }

        function updateMetalMaterials() {
            materials.forEach((material) => {
                material.roughness = materialParams.roughness;
                material.metalness = materialParams.metalness;
                material.clearcoat = materialParams.clearcoat;
                material.clearcoatRoughness = materialParams.clearcoatRoughness;
                material.envMapIntensity = materialParams.envMapIntensity;
                material.needsUpdate = true;
            });

            if (!innerMaterial) {
                return;
            }

            innerMaterial.roughness = Math.min(materialParams.roughness + 0.08, 0.3);
            innerMaterial.metalness = Math.max(materialParams.metalness - 0.25, 0.35);
            innerMaterial.clearcoat = Math.max(materialParams.clearcoat - 0.35, 0.0);
            innerMaterial.clearcoatRoughness = Math.min(materialParams.clearcoatRoughness + 0.03, 0.2);
            innerMaterial.envMapIntensity = Math.max(materialParams.envMapIntensity - 0.8, 0.8);
            innerMaterial.needsUpdate = true;
        }

        function clearPixelWall() {
            pixels.forEach((pixel) => {
                scene.remove(pixel);
            });
            pixels.length = 0;
        }

        function createPixelWall() {
            clearPixelWall();

            const rows = Math.max(1, Math.floor(config.gridRows));
            const cols = Math.max(1, Math.floor(config.gridCols));
            const gap = config.gap;
            const prototypePrism = createPrismPrototype();

            const totalWidth = cols * (UNIT_SIZE + gap);
            const totalHeight = rows * (UNIT_SIZE + gap);

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const prism = prototypePrism.clone();

                    prism.position.x = (j * (UNIT_SIZE + gap)) - (totalWidth / 2) + (UNIT_SIZE / 2);
                    prism.position.y = (i * (UNIT_SIZE + gap)) - (totalHeight / 2) + (UNIT_SIZE / 2);
                    prism.rotation.set(config.initRotationX, config.initRotationY, config.initRotationZ);
                    prism.userData = {
                        baseRotationX: config.initRotationX,
                        faceIndex: 0,
                        currentOn: false,
                        targetOn: false,
                        targetRotationX: config.initRotationX,
                        isAnimating: false
                    };

                    prism.traverse((child) => {
                        if (child.isMesh) {
                            child.userData.parentGroup = prism;
                        }
                    });

                    scene.add(prism);
                    pixels.push(prism);
                }
            }

            if (playbackState.lastText) {
                const grid = renderTextToGrid(playbackState.lastText);
                applyTextGrid(grid, true);
            }
        }

        function updatePositions() {
            const rows = Math.max(1, Math.floor(config.gridRows));
            const cols = Math.max(1, Math.floor(config.gridCols));
            const gap = config.gap;

            if (pixels.length !== rows * cols) {
                createPixelWall();
                return;
            }

            const totalWidth = cols * (UNIT_SIZE + gap);
            const totalHeight = rows * (UNIT_SIZE + gap);

            // 重新计算并应用所有像素的位置
            // 注意：pixels 数组是一维的，顺序是按行生成 (i=0..rows, j=0..cols)
            let index = 0;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const prism = pixels[index++];
                    if (prism) {
                        prism.position.x = (j * (UNIT_SIZE + gap)) - (totalWidth / 2) + (UNIT_SIZE / 2);
                        prism.position.y = (i * (UNIT_SIZE + gap)) - (totalHeight / 2) + (UNIT_SIZE / 2);
                    }
                }
            }
        }

        function parseDisplaySequence(raw) {
            return String(raw || '')
                .split(/[\n|,;]+/)
                .map(item => item.trim())
                .filter(Boolean);
        }

        function normalizeDisplayText(text) {
            return String(text || '').trim();
        }

        function containsOnlyPixelFontChars(text) {
            const upper = normalizeDisplayText(text).toUpperCase();
            if (!upper) return true;
            for (const ch of upper) {
                if (!PIXEL_FONT[ch]) {
                    return false;
                }
            }
            return true;
        }

        function buildPixelFontBitmap(text) {
            const upper = normalizeDisplayText(text).toUpperCase() || ' ';
            const glyphs = [];
            let width = 0;

            for (const ch of upper) {
                const glyph = PIXEL_FONT[ch] || PIXEL_FONT[' '];
                const glyphWidth = glyph[0].length;
                glyphs.push({ glyph, width: glyphWidth });
                width += glyphWidth;
            }
            if (glyphs.length > 1) {
                width += FONT_SPACING * (glyphs.length - 1);
            }

            const bitmap = Array.from({ length: FONT_HEIGHT }, () => Array(width).fill(0));
            let offsetX = 0;
            glyphs.forEach((item, idx) => {
                for (let y = 0; y < FONT_HEIGHT; y++) {
                    const row = item.glyph[y] || '00000';
                    for (let x = 0; x < item.width; x++) {
                        if (row[x] === '1') {
                            bitmap[y][offsetX + x] = 1;
                        }
                    }
                }
                offsetX += item.width + (idx < glyphs.length - 1 ? FONT_SPACING : 0);
            });

            return { bitmap, width, height: FONT_HEIGHT };
        }

        function scaleBitmapToGrid(bitmap, sourceWidth, sourceHeight, targetCols, targetRows) {
            const scaleFactor = Math.max(sourceWidth / targetCols, sourceHeight / targetRows, 1);
            const targetW = Math.min(targetCols, Math.max(1, Math.floor(sourceWidth / scaleFactor)));
            const targetH = Math.min(targetRows, Math.max(1, Math.floor(sourceHeight / scaleFactor)));

            const scaled = Array.from({ length: targetRows }, () => Array(targetCols).fill(0));
            const startCol = Math.floor((targetCols - targetW) / 2);
            const startRow = Math.floor((targetRows - targetH) / 2);

            for (let ty = 0; ty < targetH; ty++) {
                const y0 = Math.floor(ty * scaleFactor);
                const y1 = Math.min(sourceHeight, Math.floor((ty + 1) * scaleFactor));

                for (let tx = 0; tx < targetW; tx++) {
                    const x0 = Math.floor(tx * scaleFactor);
                    const x1 = Math.min(sourceWidth, Math.floor((tx + 1) * scaleFactor));

                    let on = 0;
                    for (let y = y0; y < y1 && !on; y++) {
                        for (let x = x0; x < x1; x++) {
                            if (bitmap[y][x]) {
                                on = 1;
                                break;
                            }
                        }
                    }

                    if (on) {
                        scaled[startRow + ty][startCol + tx] = 1;
                    }
                }
            }

            return scaled;
        }

        function estimateContentWidthCells(text) {
            const content = normalizeDisplayText(text);
            if (!content) return 1;
            if (containsOnlyPixelFontChars(content)) {
                return buildPixelFontBitmap(content).width;
            }
            const cjkCount = (content.match(/[\u3400-\u9FFF]/g) || []).length;
            const latinCount = Array.from(content).length - cjkCount;
            return Math.ceil(cjkCount * 5 + latinCount * 3.2);
        }

        function decideActiveColumns(text, totalCols) {
            const compactCols = clamp(Math.floor(displayConfig.compactCols), 4, Math.max(4, totalCols));
            if (!displayConfig.autoExpand) {
                return compactCols;
            }
            const neededCols = estimateContentWidthCells(text);
            return neededCols > compactCols ? totalCols : compactCols;
        }

        function waitMs(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getPixelByGrid(row, col) {
            const rows = Math.max(1, Math.floor(config.gridRows));
            const cols = Math.max(1, Math.floor(config.gridCols));
            const mappedRow = rows - 1 - row;
            const idx = mappedRow * cols + col;
            return pixels[idx] || null;
        }

        function setPixelDisplayState(row, col, on, immediate = false) {
            const group = getPixelByGrid(row, col);
            if (!group) return;

            const targetFace = on ? Math.max(1, Math.min(2, Math.floor(displayConfig.onFace))) : 0;
            const targetRotation = group.userData.baseRotationX + targetFace * (Math.PI * 2 / 3);
            group.userData.targetOn = on;
            group.userData.targetRotationX = targetRotation;

            if (immediate) {
                group.rotation.x = targetRotation;
                group.userData.faceIndex = targetFace;
                group.userData.currentOn = on;
                group.userData.isAnimating = false;
                return;
            }

            group.userData.isAnimating = true;
        }

        function applyTextGrid(grid, immediate = false) {
            const rows = Math.max(1, Math.floor(config.gridRows));
            const cols = Math.max(1, Math.floor(config.gridCols));
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    setPixelDisplayState(row, col, grid[row][col] === 1, immediate);
                }
            }
        }

        function renderCanvasBitmapToGrid(text, targetCols, targetRows) {
            const width = Math.max(128, targetCols * 28);
            const height = Math.max(64, targetRows * 28);

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                return Array.from({ length: targetRows }, () => Array(targetCols).fill(0));
            }

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#ffffff';

            const content = normalizeDisplayText(text) || ' ';
            const weight = displayConfig.bold ? '700' : '500';
            const fontFamily = '"PingFang SC","Hiragino Sans GB","Microsoft YaHei","Noto Sans CJK SC","Segoe UI",sans-serif';

            let fontSize = Math.floor(height * 0.66 * clamp(displayConfig.textScale, 0.35, 1.0));
            fontSize = Math.max(12, Math.min(fontSize, Math.floor(height * 0.9)));
            ctx.font = `${weight} ${fontSize}px ${fontFamily}`;

            const maxTextWidth = width * 0.9;
            while (ctx.measureText(content).width > maxTextWidth && fontSize > 10) {
                fontSize -= 2;
                ctx.font = `${weight} ${fontSize}px ${fontFamily}`;
            }

            ctx.fillText(content, width / 2, height / 2);

            const image = ctx.getImageData(0, 0, width, height).data;
            const threshold = clamp(displayConfig.threshold, 0, 255);
            const bitmap = Array.from({ length: height }, () => Array(width).fill(0));

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const alpha = image[idx + 3];
                    const lum = image[idx];
                    bitmap[y][x] = alpha > threshold && lum > threshold ? 1 : 0;
                }
            }

            return scaleBitmapToGrid(bitmap, width, height, targetCols, targetRows);
        }

        function renderTextToGrid(text) {
            const rows = Math.max(1, Math.floor(config.gridRows));
            const cols = Math.max(1, Math.floor(config.gridCols));
            const grid = Array.from({ length: rows }, () => Array(cols).fill(0));
            const content = normalizeDisplayText(text);
            const activeCols = decideActiveColumns(content, cols);
            const startCol = Math.floor((cols - activeCols) / 2);

            let compactGrid;
            if (containsOnlyPixelFontChars(content)) {
                const built = buildPixelFontBitmap(content || ' ');
                compactGrid = scaleBitmapToGrid(built.bitmap, built.width, built.height, activeCols, rows);
            } else {
                compactGrid = renderCanvasBitmapToGrid(content || ' ', activeCols, rows);
            }

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < activeCols; col++) {
                    grid[row][startCol + col] = compactGrid[row][col];
                }
            }

            return grid;
        }

        function previewCurrentSequenceText() {
            const items = parseDisplaySequence(displayConfig.sequence);
            const text = items.length > 0 ? items[0] : '';
            playbackState.lastText = text;
            const grid = renderTextToGrid(text);
            applyTextGrid(grid);
        }

        function stopPlayback() {
            playbackState.running = false;
            playbackState.runId += 1;
        }

        async function startPlayback() {
            const items = parseDisplaySequence(displayConfig.sequence);
            if (items.length === 0 || pixels.length === 0) {
                return;
            }

            stopPlayback();
            playbackState.running = true;
            const runId = playbackState.runId;
            setPanelVisible(false);

            let index = 0;
            while (playbackState.running && runId === playbackState.runId) {
                const text = items[index];
                playbackState.lastText = text;
                const grid = renderTextToGrid(text);
                applyTextGrid(grid);
                await waitMs(Math.max(200, Math.floor(displayConfig.intervalMs)));
                if (!playbackState.running || runId !== playbackState.runId) {
                    break;
                }
                index += 1;
                if (index >= items.length) {
                    if (displayConfig.loop) {
                        index = 0;
                    } else {
                        break;
                    }
                }
            }

            playbackState.running = false;
        }

        function initResources() {
            // 1. Plate Geometry
            const PLATE_WIDTH = UNIT_SIZE * PLATE_SCALE;
            plateGeometry = createRoundedPlateGeometry(
                UNIT_SIZE,
                PLATE_WIDTH,
                PLATE_THICKNESS,
                BEVEL_THICKNESS,
                CORNER_RADIUS
            );

            // 2. Inner Prism Geometry
            innerGeometry = createInnerPrismGeometry(
                innerParams.size,
                innerParams.length,
                innerParams.radius,
                innerParams.bevel
            );

            // 3. Materials
            const colors = [
                buildFaceColor(1),
                buildFaceColor(2),
                buildFaceColor(3)
            ];

            materials = colors.map(c => new THREE.MeshPhysicalMaterial({
                color: c,
                roughness: materialParams.roughness,
                metalness: materialParams.metalness,
                clearcoat: materialParams.clearcoat,
                clearcoatRoughness: materialParams.clearcoatRoughness,
                envMapIntensity: materialParams.envMapIntensity,
                side: THREE.DoubleSide
            }));

            innerMaterial = new THREE.MeshPhysicalMaterial({
                color: innerParams.color,
                roughness: 0.14,
                metalness: 0.8,
                clearcoat: 0.4,
                clearcoatRoughness: 0.08,
                envMapIntensity: 2.4
            });
        }

        function createPrismPrototype() {
            const group = new THREE.Group();

            // 1. Create 3 Plates
            const apothem = UNIT_SIZE / (2 * Math.sqrt(3));
            const distance = apothem - PLATE_THICKNESS / 2 + GAP_OFFSET;

            // Angles: Top (90), Right (-30), Left (210)
            const angles = [Math.PI / 2, -Math.PI / 6, 7 * Math.PI / 6];

            for (let i = 0; i < 3; i++) {
                const plate = new THREE.Mesh(plateGeometry, materials[i]);
                plate.castShadow = true;
                plate.receiveShadow = true;

                const angle = angles[i];
                plate.position.set(0, distance * Math.sin(angle), distance * Math.cos(angle));
                plate.rotation.x = -angle;

                group.add(plate);
            }

            // 2. Create Inner Prism
            const inner = new THREE.Mesh(innerGeometry, innerMaterial);
            inner.rotation.y = Math.PI / 2; // Rotate to align X axis
            inner.position.set(innerParams.x, innerParams.y, innerParams.z);

            group.add(inner);

            return group;
        }

        function createRoundedPlateGeometry(width, height, thickness, bevel, radius) {
            const shape = new THREE.Shape();
            const w = width;
            const h = height;
            const r = radius;

            const x = -w / 2;
            const y = -h / 2;

            shape.moveTo(x + r, y);
            shape.lineTo(x + w - r, y);
            shape.quadraticCurveTo(x + w, y, x + w, y + r);
            shape.lineTo(x + w, y + h - r);
            shape.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            shape.lineTo(x + r, y + h);
            shape.quadraticCurveTo(x, y + h, x, y + h - r);
            shape.lineTo(x, y + r);
            shape.quadraticCurveTo(x, y, x + r, y);

            const extrudeSettings = {
                steps: 1,
                depth: thickness,
                bevelEnabled: true,
                bevelThickness: bevel,
                bevelSize: bevel,
                bevelSegments: 3
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.computeBoundingBox();
            const centerOffset = -0.5 * (geometry.boundingBox.max.z - geometry.boundingBox.min.z);
            geometry.translate(0, 0, centerOffset);

            return geometry;
        }

        function createInnerPrismGeometry(size, length, radius, bevel) {
            const shape = new THREE.Shape();
            const R = size;
            const r = radius;

            const angleStart = -Math.PI / 2;
            const angleStep = Math.PI * 2 / 3;
            const dist = R - 2 * r;

            for (let i = 0; i < 3; i++) {
                const angle = angleStart + i * angleStep;
                const cx = dist * Math.cos(angle);
                const cy = dist * Math.sin(angle);
                shape.absarc(cx, cy, r, angle - Math.PI / 3, angle + Math.PI / 3, false);
            }
            shape.closePath();

            const extrudeSettings = {
                steps: 1,
                depth: length,
                bevelEnabled: true,
                bevelThickness: bevel,
                bevelSize: bevel,
                bevelSegments: 5
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            // Center along Z only
            geometry.translate(0, 0, -length / 2);
            return geometry;
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!isCameraInteracting && !playbackState.running) {
                raycaster.setFromCamera(mouse, camera);

                // Raycast recursively to hit meshes inside groups
                const intersects = raycaster.intersectObjects(scene.children, true);

                if (intersects.length > 0) {
                    let obj = intersects[0].object;

                    // Traverse up to find the pixel group
                    let targetGroup = null;
                    if (obj.userData.parentGroup) {
                        targetGroup = obj.userData.parentGroup;
                    } else {
                        // Fallback traverse
                        let curr = obj;
                        while (curr.parent && !pixels.includes(curr)) {
                            curr = curr.parent;
                        }
                        if (pixels.includes(curr)) targetGroup = curr;
                    }

                    if (targetGroup && !targetGroup.userData.isAnimating) {
                        targetGroup.userData.isAnimating = true;
                        targetGroup.userData.targetRotationX += (Math.PI * 2) / 3;
                        const face = Math.round(
                            (targetGroup.userData.targetRotationX - targetGroup.userData.baseRotationX) / ((Math.PI * 2) / 3)
                        );
                        targetGroup.userData.targetOn = ((face % 3) + 3) % 3 !== 0;
                    }
                }
            }

            pixels.forEach(group => {
                if (group.userData.isAnimating) {
                    // Smooth rotation using linear interpolation for consistent speed, 
                    // or lerp for ease-out. Let's use ease-out for premium feel.
                    const speed = 0.1;
                    const diff = group.userData.targetRotationX - group.rotation.x;

                    if (Math.abs(diff) < 0.005) {
                        group.rotation.x = group.userData.targetRotationX;
                        group.userData.isAnimating = false;
                        const face = Math.round(
                            (group.userData.targetRotationX - group.userData.baseRotationX) / ((Math.PI * 2) / 3)
                        );
                        group.userData.faceIndex = ((face % 3) + 3) % 3;
                        group.userData.currentOn = group.userData.faceIndex !== 0;
                    } else {
                        group.rotation.x += diff * speed;
                    }
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>

</html>
