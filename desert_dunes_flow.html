<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Flowing Desert Dunes</title>
  <style>
    :root {
      color-scheme: dark;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: #010103;
      font-family: "PingFang SC", "Noto Sans SC", sans-serif;
    }

    #app {
      width: 100%;
      height: 100%;
    }

    .hint {
      position: fixed;
      left: 16px;
      bottom: 16px;
      color: rgba(255, 214, 140, 0.72);
      font-size: 12px;
      letter-spacing: 0.06em;
      user-select: none;
      pointer-events: none;
      text-transform: uppercase;
      mix-blend-mode: screen;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hint">Flowing Desert Dunes</div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";

    const container = document.getElementById("app");

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setClearColor(0x010103, 1);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

    const geometry = new THREE.PlaneGeometry(2, 2);

    const material = new THREE.ShaderMaterial({
      uniforms: {
        u_time: { value: 0 },
        u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
      },
      vertexShader: `
        varying vec2 vUv;

        void main() {
          vUv = uv;
          gl_Position = vec4(position.xy, 0.0, 1.0);
        }
      `,
      fragmentShader: `
        precision highp float;

        uniform float u_time;
        uniform vec2 u_resolution;
        varying vec2 vUv;

        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
        }

        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          vec2 u = f * f * (3.0 - 2.0 * f);

          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));

          return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
        }

        float fbm(vec2 p) {
          float value = 0.0;
          float amp = 0.5;
          for (int i = 0; i < 5; i++) {
            value += amp * noise(p);
            p = p * 2.0 + vec2(13.1, 7.7);
            amp *= 0.5;
          }
          return value;
        }

        float duneCurve(float x, float layer, float t) {
          float wave1 = sin(x * (2.8 + layer * 0.16) + t * (0.36 + layer * 0.02));
          float wave2 = sin(x * (7.2 + layer * 0.12) - t * (0.18 + layer * 0.03));
          float wave3 = sin(x * (13.0 + layer * 0.22) + t * 0.11 + layer * 0.9);
          return (wave1 * 0.70 + wave2 * 0.22 + wave3 * 0.08) * (0.045 + layer * 0.0012);
        }

        void main() {
          vec2 uv = vUv;
          float t = u_time;

          vec3 col = vec3(0.0);

          vec2 nUv = vec2(uv.x * 4.0, uv.y * 2.0);
          float haze = fbm(nUv + vec2(t * 0.05, -t * 0.02));

          float edgeMask = smoothstep(0.10, 0.42, abs(uv.y - 0.5));

          for (int i = 0; i < 18; i++) {
            float fi = float(i);
            float topLayer = 0.64 + fi * 0.026;
            float bottomLayer = 0.36 - fi * 0.024;

            float baseShift = (fbm(vec2(fi * 0.37, t * 0.07)) - 0.5) * 0.01;

            float topY = topLayer + duneCurve(uv.x * 1.6 + fi * 0.13, fi, t) + baseShift;
            float bottomY = bottomLayer + duneCurve(uv.x * 1.7 + fi * 0.11, fi + 2.0, t + 3.0) - baseShift;

            float dTop = abs(uv.y - topY);
            float dBottom = abs(uv.y - bottomY);

            float lineTop = exp(-dTop * (110.0 - fi * 1.7));
            float lineBottom = exp(-dBottom * (105.0 - fi * 1.5));

            float grainTop = 0.60 + 0.40 * noise(vec2(uv.x * 440.0 + fi * 1.7, uv.y * 290.0 - t * 10.0));
            float grainBottom = 0.58 + 0.42 * noise(vec2(uv.x * 420.0 - fi * 1.2, uv.y * 260.0 + t * 9.0));

            float topBand = lineTop * grainTop;
            float bottomBand = lineBottom * grainBottom;

            vec3 amber = vec3(1.00, 0.67, 0.21);
            vec3 gold = vec3(1.00, 0.84, 0.47);
            vec3 burn = vec3(0.78, 0.33, 0.08);

            float mixToneTop = 0.5 + 0.5 * sin(fi * 0.53 + t * 0.7 + uv.x * 8.0);
            float mixToneBottom = 0.5 + 0.5 * cos(fi * 0.48 + t * 0.6 + uv.x * 7.3);

            vec3 topColor = mix(amber, gold, mixToneTop) + burn * 0.12;
            vec3 bottomColor = mix(amber, gold, mixToneBottom) + burn * 0.10;

            col += topColor * topBand * (1.08 - fi * 0.034);
            col += bottomColor * bottomBand * (1.00 - fi * 0.030);

            float fillTop = smoothstep(0.085, 0.0, dTop) * 0.085;
            float fillBottom = smoothstep(0.085, 0.0, dBottom) * 0.08;
            col += vec3(0.35, 0.12, 0.02) * (fillTop + fillBottom);
          }

          vec2 sparkGrid = floor(vec2(uv.x * 820.0, uv.y * 420.0));
          float spark = hash(sparkGrid);
          float twinkle = smoothstep(0.975, 1.0, spark + 0.12 * sin(t * 5.2 + spark * 31.4));

          float field = 0.0;
          field += smoothstep(0.0, 0.045, col.r - 0.08);
          field *= edgeMask;

          vec3 sparkColor = mix(vec3(1.0, 0.72, 0.30), vec3(1.0, 0.95, 0.72), hash(sparkGrid + 19.0));
          col += sparkColor * twinkle * field * 0.85;

          col += vec3(0.05, 0.08, 0.16) * pow(haze, 2.2) * edgeMask * 0.35;

          float centerDark = 1.0 - smoothstep(0.05, 0.32, abs(uv.y - 0.5));
          col *= mix(1.0, 0.18, centerDark);

          float vignette = smoothstep(0.95, 0.32, distance(uv, vec2(0.5)));
          col *= vignette;

          col = pow(col, vec3(0.85));
          gl_FragColor = vec4(col, 1.0);
        }
      `
    });

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    const clock = new THREE.Clock();

    function animate() {
      material.uniforms.u_time.value = clock.getElapsedTime();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    function onResize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      material.uniforms.u_resolution.value.set(w, h);
    }

    window.addEventListener("resize", onResize);
    animate();
  </script>
</body>
</html>
