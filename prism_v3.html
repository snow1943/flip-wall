<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device=device-width, initial-scale=1.0">
    <title>三棱柱 - 金属质感版</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0a0a0a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #eee;
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 12px;
            pointer-events: none;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 320px;
        }

        #ui h3 {
            margin: 0 0 10px 0;
            font-size: 1.2rem;
            font-weight: 600;
        }

        #ui p {
            margin: 5px 0;
            font-size: 0.9rem;
            color: #ccc;
        }

        .controls-hint {
            font-size: 0.8rem !important;
            color: #888 !important;
            margin-top: 15px !important;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h3>三棱柱 - 金属质感版</h3>
        <p>基于 prism_v2，增强金属材质效果</p>
        <p>左键拖拽旋转 | 右键拖拽平移 | 滚轮缩放</p>
        <p class="controls-hint">使用 MeshPhysicalMaterial + 环境反射</p>
    </div>

    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <!-- OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- dat.GUI -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <script>
        let scene, camera, renderer, controls, prismGroup, innerPrism;
        let gui;

        // 材质参数 - 镜面金属质感
        const materialParams = {
            // 银色面
            color1: '#c0c5ce',
            roughness1: 0.08,
            metalness1: 1.0,
            clearcoat1: 1.0,
            envMapIntensity1: 3.0,

            // 金色面
            color2: '#f0c640',
            roughness2: 0.08,
            metalness2: 1.0,
            clearcoat2: 1.0,
            envMapIntensity2: 3.0,

            // 铜色面
            color3: '#cd7f32',
            roughness3: 0.08,
            metalness3: 1.0,
            clearcoat3: 1.0,
            envMapIntensity3: 3.0,
        };

        // 内芯参数配置
        const innerParams = {
            size: 0.54,
            length: 0.84,
            radius: 0.05,
            bevel: 0.0,
            color: '#111111',
            visible: true,
            x: 0,
            y: 0,
            z: 0
        };

        // 尺寸定义
        const UNIT_SIZE = 1.0;
        const PLATE_THICKNESS = 0.001;
        const BEVEL_THICKNESS = 0.001;
        const CORNER_RADIUS = 0.3;
        const GAP_OFFSET = 0.00;
        const PLATE_SCALE = 1.0;

        function init() {
            // 场景初始化
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // 相机设置
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(3, 2, 4);

            // 渲染器设置 - 提高渲染质量
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.antialias = true;
            document.body.appendChild(renderer.domElement);

            // 控制器设置
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.5;
            controls.minDistance = 2;
            controls.maxDistance = 20;
            // 移除垂直角度限制，允许360度旋转
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = Math.PI;

            // 灯光设置 - 强化金属质感
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);

            // 主光源 - 强光
            const keyLight = new THREE.DirectionalLight(0xffffff, 1.8);
            keyLight.position.set(5, 8, 5);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            keyLight.shadow.bias = -0.001;
            scene.add(keyLight);

            // 补光 - 冷色调
            const fillLight = new THREE.DirectionalLight(0xaaccff, 0.8);
            fillLight.position.set(-5, 2, -5);
            scene.add(fillLight);

            // 轮廓光 - 暖色调
            const rimLight = new THREE.DirectionalLight(0xffddaa, 1.0);
            rimLight.position.set(-3, -5, 8);
            scene.add(rimLight);

            // 背光 - 增强轮廓
            const backLight = new THREE.DirectionalLight(0xffffff, 0.6);
            backLight.position.set(0, -3, -8);
            scene.add(backLight);

            // 多彩点光源 - 丰富反射
            const colors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181, 0xaa96da, 0xfcbad3, 0xa8d8ea];
            const positions = [
                { x: 4, y: 3, z: 3 },
                { x: -4, y: -2, z: 3 },
                { x: 3, y: -3, z: -2 },
                { x: -3, y: 4, z: 2 },
                { x: 2, y: 1, z: -4 },
                { x: -2, y: -1, z: 4 },
                { x: 0, y: 5, z: 0 },
                { x: 5, y: 0, z: -3 }
            ];

            for (let i = 0; i < colors.length; i++) {
                const light = new THREE.PointLight(colors[i], 0.5, 15);
                light.position.set(positions[i].x, positions[i].y, positions[i].z);
                scene.add(light);
            }

            // 加载环境贴图
            loadEnvironment();

            // 初始化 GUI
            initGUI();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function loadEnvironment() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();

            const hdrUrl = 'https://threejs.org/examples/textures/equirectangular/royal_esplanade_1k.hdr';
            const rgbeLoader = new THREE.RGBELoader();
            rgbeLoader.load(
                hdrUrl,
                (hdrTexture) => {
                    const envMap = pmremGenerator.fromEquirectangular(hdrTexture).texture;
                    scene.environment = envMap;
                    hdrTexture.dispose();
                    pmremGenerator.dispose();

                    // 环境加载后创建三棱柱
                    createPrism();
                },
                undefined,
                () => {
                    // 加载失败，使用 fallback 环境
                    scene.environment = createFallbackEnvironment(pmremGenerator);
                    pmremGenerator.dispose();
                    createPrism();
                }
            );
        }

        function createFallbackEnvironment(pmremGenerator) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // 丰富的渐变背景 - 深色基底
            const bg = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bg.addColorStop(0.0, '#1a1a2e');
            bg.addColorStop(0.2, '#16213e');
            bg.addColorStop(0.4, '#1f4068');
            bg.addColorStop(0.6, '#1f4068');
            bg.addColorStop(0.8, '#16213e');
            bg.addColorStop(1.0, '#1a1a2e');
            ctx.fillStyle = bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 多彩强光带 - 增加反射丰富度
            const lightStrips = [
                { x: 100, w: 60, color: '#ffffff', alpha: 0.9 },
                { x: 250, w: 40, color: '#ffeaa7', alpha: 0.7 },
                { x: 350, w: 80, color: '#74b9ff', alpha: 0.6 },
                { x: 480, w: 100, color: '#ffffff', alpha: 0.85 },
                { x: 620, w: 50, color: '#fd79a8', alpha: 0.5 },
                { x: 720, w: 70, color: '#55efc4', alpha: 0.6 },
                { x: 850, w: 40, color: '#a29bfe', alpha: 0.5 },
                { x: 950, w: 60, color: '#ffffff', alpha: 0.8 }
            ];

            lightStrips.forEach(strip => {
                ctx.globalAlpha = strip.alpha;
                ctx.fillStyle = strip.color;
                ctx.fillRect(strip.x, 0, strip.w, canvas.height);
            });

            // 中等亮度光带
            const midStrips = [
                { x: 0, y: 100, h: 60, color: '#fdcb6e', alpha: 0.3 },
                { x: 150, y: 250, h: 80, color: '#81ecec', alpha: 0.25 },
                { x: 400, y: 180, h: 50, color: '#fab1a0', alpha: 0.2 },
                { x: 600, y: 300, h: 70, color: '#dfe6e9', alpha: 0.3 },
                { x: 800, y: 150, h: 60, color: '#ffeaa7', alpha: 0.25 }
            ];

            midStrips.forEach(strip => {
                ctx.globalAlpha = strip.alpha;
                ctx.fillStyle = strip.color;
                ctx.fillRect(strip.x, strip.y, canvas.width, strip.h);
            });

            // 散点高光 - 模拟星星点点的光源
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 8 + 2;
                const brightness = Math.random() * 0.5 + 0.3;

                ctx.globalAlpha = brightness;
                ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#ffeaa7';
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.globalAlpha = 1.0;

            const texture = new THREE.CanvasTexture(canvas);
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.encoding = THREE.sRGBEncoding;
            const envMap = pmremGenerator.fromEquirectangular(texture).texture;
            texture.dispose();
            return envMap;
        }

        function createPrism() {
            // 创建三棱柱组
            prismGroup = new THREE.Group();

            // 颜色定义 - 金属质感颜色
            const colors = [
                new THREE.Color(materialParams.color1),
                new THREE.Color(materialParams.color2),
                new THREE.Color(materialParams.color3)
            ];

            const apothem = UNIT_SIZE / (2 * Math.sqrt(3));
            const distance = apothem - PLATE_THICKNESS / 2 + GAP_OFFSET;

            const PLATE_WIDTH = UNIT_SIZE * PLATE_SCALE;
            const plateGeometry = createRoundedPlateGeometry(UNIT_SIZE, PLATE_WIDTH, PLATE_THICKNESS, BEVEL_THICKNESS, CORNER_RADIUS);

            for (let i = 0; i < 3; i++) {
                // 使用 MeshPhysicalMaterial 实现金属质感
                const material = new THREE.MeshPhysicalMaterial({
                    color: colors[i],
                    roughness: materialParams['roughness' + (i + 1)],
                    metalness: materialParams['metalness' + (i + 1)],
                    clearcoat: materialParams['clearcoat' + (i + 1)],
                    clearcoatRoughness: 0.03,
                    envMapIntensity: materialParams['envMapIntensity' + (i + 1)],
                    side: THREE.DoubleSide
                });

                const plate = new THREE.Mesh(plateGeometry, material);
                plate.castShadow = true;
                plate.receiveShadow = true;

                const viewingAngles = [Math.PI / 2, -Math.PI / 6, -5 * Math.PI / 6];
                const currentAngle = viewingAngles[i];

                plate.position.set(0, distance * Math.sin(currentAngle), distance * Math.cos(currentAngle));
                plate.rotation.x = -currentAngle;

                prismGroup.add(plate);
            }

            scene.add(prismGroup);

            // 添加坐标轴辅助线
            const axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);

            // 初始化内芯
            generateInnerPrism();
        }

        function initGUI() {
            gui = new dat.GUI();

            // 材质参数
            const matFolder = gui.addFolder('材质参数 (金属质感)');

            // 银色面
            const mat1Folder = matFolder.addFolder('面1 (银色)');
            mat1Folder.addColor(materialParams, 'color1').name('颜色').onChange(updateMaterials);
            mat1Folder.add(materialParams, 'roughness1', 0.02, 0.3).name('粗糙度').onChange(updateMaterials);
            mat1Folder.add(materialParams, 'metalness1', 0.8, 1).name('金属度').onChange(updateMaterials);
            mat1Folder.add(materialParams, 'clearcoat1', 0.3, 1).name('清漆层').onChange(updateMaterials);
            mat1Folder.add(materialParams, 'envMapIntensity1', 1, 4).name('反射强度').onChange(updateMaterials);

            // 金色面
            const mat2Folder = matFolder.addFolder('面2 (金色)');
            mat2Folder.addColor(materialParams, 'color2').name('颜色').onChange(updateMaterials);
            mat2Folder.add(materialParams, 'roughness2', 0.02, 0.3).name('粗糙度').onChange(updateMaterials);
            mat2Folder.add(materialParams, 'metalness2', 0.8, 1).name('金属度').onChange(updateMaterials);
            mat2Folder.add(materialParams, 'clearcoat2', 0.3, 1).name('清漆层').onChange(updateMaterials);
            mat2Folder.add(materialParams, 'envMapIntensity2', 1, 4).name('反射强度').onChange(updateMaterials);

            // 铜色面
            const mat3Folder = matFolder.addFolder('面3 (铜色)');
            mat3Folder.addColor(materialParams, 'color3').name('颜色').onChange(updateMaterials);
            mat3Folder.add(materialParams, 'roughness3', 0.02, 0.3).name('粗糙度').onChange(updateMaterials);
            mat3Folder.add(materialParams, 'metalness3', 0.8, 1).name('金属度').onChange(updateMaterials);
            mat3Folder.add(materialParams, 'clearcoat3', 0.3, 1).name('清漆层').onChange(updateMaterials);
            mat3Folder.add(materialParams, 'envMapIntensity3', 1, 4).name('反射强度').onChange(updateMaterials);

            matFolder.open();

            // 内芯参数
            const innerFolder = gui.addFolder('内芯参数');
            innerFolder.add(innerParams, 'visible').name('显示内芯').onChange(v => {
                if (innerPrism) innerPrism.visible = v;
            });
            innerFolder.add(innerParams, 'length', 0.1, 1.2).name('长度').onChange(generateInnerPrism);
            innerFolder.add(innerParams, 'size', 0.1, 0.8).name('大小').onChange(generateInnerPrism);
            innerFolder.add(innerParams, 'radius', 0.0, 0.2).name('圆角').onChange(generateInnerPrism);
            innerFolder.add(innerParams, 'bevel', 0.0, 0.05).name('倒角').onChange(generateInnerPrism);
            innerFolder.addColor(innerParams, 'color').name('颜色').onChange(v => {
                if (innerPrism) innerPrism.material.color.set(v);
            });

            const posFolder = innerFolder.addFolder('位置');
            posFolder.add(innerParams, 'x', -1, 1).name('X').step(0.01).onChange(updateInnerPosition);
            posFolder.add(innerParams, 'y', -1, 1).name('Y').step(0.01).onChange(updateInnerPosition);
            posFolder.add(innerParams, 'z', -1, 1).name('Z').step(0.01).onChange(updateInnerPosition);
            posFolder.open();
        }

        function updateMaterials() {
            if (!prismGroup) return;

            const colors = [
                new THREE.Color(materialParams.color1),
                new THREE.Color(materialParams.color2),
                new THREE.Color(materialParams.color3)
            ];

            prismGroup.children.forEach((child, i) => {
                if (child.isMesh && child.material) {
                    child.material.color.copy(colors[i]);
                    child.material.roughness = materialParams['roughness' + (i + 1)];
                    child.material.metalness = materialParams['metalness' + (i + 1)];
                    child.material.clearcoat = materialParams['clearcoat' + (i + 1)];
                    child.material.envMapIntensity = materialParams['envMapIntensity' + (i + 1)];
                    child.material.needsUpdate = true;
                }
            });
        }

        function updateInnerPosition() {
            if (innerPrism) {
                innerPrism.position.set(innerParams.x, innerParams.y, innerParams.z);
            }
        }

        function generateInnerPrism() {
            if (innerPrism) {
                scene.remove(innerPrism);
                innerPrism.geometry.dispose();
                innerPrism.material.dispose();
            }

            if (!innerParams.visible) return;

            const geometry = createInnerPrismGeometry(
                innerParams.size,
                innerParams.length,
                innerParams.radius,
                innerParams.bevel
            );

            const material = new THREE.MeshPhysicalMaterial({
                color: innerParams.color,
                roughness: 0.1,
                metalness: 0.8,
                clearcoat: 0.5,
                clearcoatRoughness: 0.05,
                envMapIntensity: 1.5
            });

            innerPrism = new THREE.Mesh(geometry, material);
            innerPrism.rotation.y = Math.PI / 2;
            innerPrism.position.set(innerParams.x, innerParams.y, innerParams.z);

            scene.add(innerPrism);
        }

        function createInnerPrismGeometry(size, length, radius, bevel) {
            const shape = new THREE.Shape();
            const R = size;
            const r = radius;

            const angleStart = -Math.PI / 2;
            const angleStep = Math.PI * 2 / 3;
            const dist = R - 2 * r;

            for (let i = 0; i < 3; i++) {
                const angle = angleStart + i * angleStep;
                const cx = dist * Math.cos(angle);
                const cy = dist * Math.sin(angle);
                shape.absarc(cx, cy, r, angle - Math.PI / 3, angle + Math.PI / 3, false);
            }
            shape.closePath();

            const extrudeSettings = {
                steps: 1,
                depth: length,
                bevelEnabled: true,
                bevelThickness: bevel,
                bevelSize: bevel,
                bevelSegments: 5
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.translate(0, 0, -length / 2);
            return geometry;
        }

        function createRoundedPlateGeometry(width, height, thickness, bevel, radius) {
            const shape = new THREE.Shape();
            const w = width;
            const h = height;
            const r = radius;

            const x = -w / 2;
            const y = -h / 2;

            shape.moveTo(x + r, y);
            shape.lineTo(x + w - r, y);
            shape.quadraticCurveTo(x + w, y, x + w, y + r);
            shape.lineTo(x + w, y + h - r);
            shape.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            shape.lineTo(x + r, y + h);
            shape.quadraticCurveTo(x, y + h, x, y + h - r);
            shape.lineTo(x, y + r);
            shape.quadraticCurveTo(x, y, x + r, y);

            const extrudeSettings = {
                steps: 1,
                depth: thickness,
                bevelEnabled: true,
                bevelThickness: bevel,
                bevelSize: bevel,
                bevelSegments: 3
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.computeBoundingBox();
            const centerOffset = -0.5 * (geometry.boundingBox.max.z - geometry.boundingBox.min.z);
            geometry.translate(0, 0, centerOffset);

            return geometry;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>

</html>
