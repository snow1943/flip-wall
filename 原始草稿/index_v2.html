<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 翻转墙 - 最终版</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #eee;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            z-index: 10;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h2>3D 像素翻转墙</h2>
        <p>鼠标划过像素即可触发 120 度翻转动画</p>
    </div>

    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- dat.GUI -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <script>
        let scene, camera, renderer, raycaster, mouse;
        let spotLight, fillLight; // [修改] 改用聚光灯
        const pixels = []; // Stores the prism groups
        const rows = 12;
        const cols = 22;
        const gap = 0.03;

        // Constants from prism_v2.html adjustment
        const UNIT_SIZE = 1.0;
        const PLATE_THICKNESS = 0.001;
        const BEVEL_THICKNESS = 0.001;
        const CORNER_RADIUS = 0.3;
        const GAP_OFFSET = 0.0;
        const PLATE_SCALE = 1.0;

        const innerParams = {
            size: 0.54,
            length: 0.84,
            radius: 0.05,
            bevel: 0.0,
            color: '#111111',
            x: 0,
            y: 0,
            color: '#111111',
            x: 0,
            y: 0,
            z: 0
        };

        // 初始配置
        const config = {
            initRotationX: Math.PI / 2, // 90度，让面完全垂直
            initRotationY: 0.0,
            initRotationZ: 0.0,
            gap: 0.057, // [已修改] 默认间距

            // 相机设置
            camX: 0, camY: 0, camZ: 20,
            viewSize: 14,


            // 灯光设置 (聚光灯)
            spotLightX: 5, spotLightY: 10, spotLightZ: 30, // 增加距离以覆盖全墙
            spotLightIntensity: 0.8,
            spotLightAngle: Math.PI / 4, // 45度
            spotLightPenumbra: 0.5, // 边缘柔化

            fillLightX: -5, fillLightY: 2, fillLightZ: 20,
            fillLightIntensity: 0.4
        };

        // Shared Geometry and Material (for performance)
        let plateGeometry, innerGeometry;
        let materials = [];
        let innerMaterial;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Using configuration for camera
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = config.viewSize;
            camera = new THREE.OrthographicCamera(
                -viewSize * aspect / 2, viewSize * aspect / 2,
                viewSize / 2, -viewSize / 2,
                0.1, 1000
            );
            camera.position.set(config.camX, config.camY, config.camZ);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; // Enable shadows if needed
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting from prism_v2
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // 主光源：改用 SpotLight 以获得柔和边缘和圆形光照
            spotLight = new THREE.SpotLight(0xffffff, config.spotLightIntensity);
            spotLight.position.set(config.spotLightX, config.spotLightY, config.spotLightZ);
            spotLight.angle = config.spotLightAngle;
            spotLight.penumbra = config.spotLightPenumbra; // 关键：让边缘柔和
            spotLight.decay = 1.5; // 物理衰减
            spotLight.distance = 100;

            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 2048; // 提高阴影质量
            spotLight.shadow.mapSize.height = 2048;
            spotLight.shadow.bias = -0.0001;
            scene.add(spotLight);

            fillLight = new THREE.DirectionalLight(0xbbaaff, config.fillLightIntensity);
            fillLight.position.set(config.fillLightX, config.fillLightY, config.fillLightZ);
            scene.add(fillLight);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2(-1, -1);

            // Pre-create geometries and materials
            initResources();

            // Prototype Prism Group
            const prototypePrism = createPrismPrototype();

            const totalWidth = cols * (UNIT_SIZE + gap);
            const totalHeight = rows * (UNIT_SIZE + gap);

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const prism = prototypePrism.clone();

                    // Position
                    prism.position.x = (j * (UNIT_SIZE + gap)) - (totalWidth / 2) + (UNIT_SIZE / 2);
                    prism.position.y = (i * (UNIT_SIZE + gap)) - (totalHeight / 2) + (UNIT_SIZE / 2);

                    // Initial Rotation
                    prism.rotation.set(config.initRotationX, config.initRotationY, config.initRotationZ);

                    // User Data for Animation
                    prism.userData = {
                        targetRotationX: config.initRotationX,
                        isAnimating: false
                    };

                    // We need to attach user data to the children meshes too for raycasting?
                    // Raycaster intersects objects. If recursive=true, it hits meshes.
                    // We need to traverse up to the Group.
                    prism.traverse((child) => {
                        if (child.isMesh) {
                            child.userData.parentGroup = prism;
                        }
                    });

                    scene.add(prism);
                    pixels.push(prism);
                }
            }

            initGUI();

            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function initGUI() {
            const gui = new dat.GUI();
            const folder = gui.addFolder('初始角度调整');

            const updateRotations = () => {
                pixels.forEach(p => {
                    // 只重置那些没有在动画中的，或者强制重置所有？
                    // 为了调整方便，强制重置所有位置到初始状态
                    p.rotation.set(config.initRotationX, config.initRotationY, config.initRotationZ);
                    p.userData.targetRotationX = config.initRotationX;
                    p.userData.isAnimating = false;
                });
            };

            folder.add(config, 'initRotationX', -Math.PI, Math.PI).step(0.01).name('X 轴角度').onChange(updateRotations);
            folder.add(config, 'initRotationY', -Math.PI, Math.PI).step(0.01).name('Y 轴角度').onChange(updateRotations);
            folder.add(config, 'gap', 0.0, 0.5).step(0.001).name('行列间距').onChange(updatePositions);
            folder.open();

            // 相机设置面板
            const camFolder = gui.addFolder('相机视角设置');
            const updateCamera = () => {
                camera.position.set(config.camX, config.camY, config.camZ);
                camera.lookAt(0, 0, 0);

                const aspect = window.innerWidth / window.innerHeight;
                camera.left = -config.viewSize * aspect / 2;
                camera.right = config.viewSize * aspect / 2;
                camera.top = config.viewSize / 2;
                camera.bottom = -config.viewSize / 2;
                camera.updateProjectionMatrix();
            };
            camFolder.add(config, 'camX', -50, 50).name('位置 X').onChange(updateCamera);
            camFolder.add(config, 'camY', -50, 50).name('位置 Y').onChange(updateCamera);
            camFolder.add(config, 'camZ', 0, 100).name('位置 Z').onChange(updateCamera);
            camFolder.add(config, 'viewSize', 5, 30).name('缩放 (ViewSize)').onChange(updateCamera);
            camFolder.open();

            // 灯光设置面板
            const lightFolder = gui.addFolder('光源设置');
            const updateLights = () => {
                spotLight.position.set(config.spotLightX, config.spotLightY, config.spotLightZ);
                spotLight.intensity = config.spotLightIntensity;
                spotLight.angle = config.spotLightAngle;
                spotLight.penumbra = config.spotLightPenumbra;

                fillLight.position.set(config.fillLightX, config.fillLightY, config.fillLightZ);
                fillLight.intensity = config.fillLightIntensity;
            };

            // 主光源 (SpotLight)
            lightFolder.add(config, 'spotLightX', -50, 50).name('主光 X').onChange(updateLights);
            lightFolder.add(config, 'spotLightY', -50, 50).name('主光 Y').onChange(updateLights);
            lightFolder.add(config, 'spotLightZ', 0, 100).name('主光 Z').onChange(updateLights);
            lightFolder.add(config, 'spotLightIntensity', 0, 2).name('主光强度').onChange(updateLights);
            lightFolder.add(config, 'spotLightAngle', 0, Math.PI / 2).name('光照角度').onChange(updateLights);
            lightFolder.add(config, 'spotLightPenumbra', 0, 1).name('边缘柔化').onChange(updateLights);

            // 补光 (Directional)
            lightFolder.add(config, 'fillLightX', -20, 20).name('补光 X').onChange(updateLights);
            lightFolder.add(config, 'fillLightY', -20, 20).name('补光 Y').onChange(updateLights);
            lightFolder.add(config, 'fillLightZ', -20, 20).name('补光 Z').onChange(updateLights);
            lightFolder.add(config, 'fillLightIntensity', 0, 2).name('补光强度').onChange(updateLights);
        }

        function updatePositions() {
            const gap = config.gap;
            const totalWidth = cols * (UNIT_SIZE + gap);
            const totalHeight = rows * (UNIT_SIZE + gap);

            // 重新计算并应用所有像素的位置
            // 注意：pixels 数组是一维的，顺序是按行生成 (i=0..rows, j=0..cols)
            let index = 0;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const prism = pixels[index++];
                    if (prism) {
                        prism.position.x = (j * (UNIT_SIZE + gap)) - (totalWidth / 2) + (UNIT_SIZE / 2);
                        prism.position.y = (i * (UNIT_SIZE + gap)) - (totalHeight / 2) + (UNIT_SIZE / 2);
                    }
                }
            }
        }

        function initResources() {
            // 1. Plate Geometry
            const PLATE_WIDTH = UNIT_SIZE * PLATE_SCALE;
            plateGeometry = createRoundedPlateGeometry(
                UNIT_SIZE,
                PLATE_WIDTH,
                PLATE_THICKNESS,
                BEVEL_THICKNESS,
                CORNER_RADIUS
            );

            // 2. Inner Prism Geometry
            innerGeometry = createInnerPrismGeometry(
                innerParams.size,
                innerParams.length,
                innerParams.radius,
                innerParams.bevel
            );

            // 3. Materials
            // Colors: Blue, Yellow, Red
            const colors = [
                new THREE.Color(0.2, 0.5, 0.9), // Blue
                new THREE.Color(0.9, 0.8, 0.1), // Yellow
                new THREE.Color(0.9, 0.2, 0.4)  // Red
            ];

            materials = colors.map(c => new THREE.MeshStandardMaterial({
                color: c,
                roughness: 0.3,
                metalness: 0.1,
            }));

            innerMaterial = new THREE.MeshStandardMaterial({
                color: innerParams.color,
                roughness: 0.2,
                metalness: 0.2
            });
        }

        function createPrismPrototype() {
            const group = new THREE.Group();

            // 1. Create 3 Plates
            const apothem = UNIT_SIZE / (2 * Math.sqrt(3));
            const distance = apothem - PLATE_THICKNESS / 2 + GAP_OFFSET;

            // Angles: Top (90), Right (-30), Left (210)
            const angles = [Math.PI / 2, -Math.PI / 6, 7 * Math.PI / 6];

            for (let i = 0; i < 3; i++) {
                const plate = new THREE.Mesh(plateGeometry, materials[i]);
                plate.castShadow = true;
                plate.receiveShadow = true;

                const angle = angles[i];
                plate.position.set(0, distance * Math.sin(angle), distance * Math.cos(angle));
                plate.rotation.x = -angle;

                group.add(plate);
            }

            // 2. Create Inner Prism
            const inner = new THREE.Mesh(innerGeometry, innerMaterial);
            inner.rotation.y = Math.PI / 2; // Rotate to align X axis
            inner.position.set(innerParams.x, innerParams.y, innerParams.z);

            group.add(inner);

            return group;
        }

        function createRoundedPlateGeometry(width, height, thickness, bevel, radius) {
            const shape = new THREE.Shape();
            const w = width;
            const h = height;
            const r = radius;

            const x = -w / 2;
            const y = -h / 2;

            shape.moveTo(x + r, y);
            shape.lineTo(x + w - r, y);
            shape.quadraticCurveTo(x + w, y, x + w, y + r);
            shape.lineTo(x + w, y + h - r);
            shape.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            shape.lineTo(x + r, y + h);
            shape.quadraticCurveTo(x, y + h, x, y + h - r);
            shape.lineTo(x, y + r);
            shape.quadraticCurveTo(x, y, x + r, y);

            const extrudeSettings = {
                steps: 1,
                depth: thickness,
                bevelEnabled: true,
                bevelThickness: bevel,
                bevelSize: bevel,
                bevelSegments: 3
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.computeBoundingBox();
            const centerOffset = -0.5 * (geometry.boundingBox.max.z - geometry.boundingBox.min.z);
            geometry.translate(0, 0, centerOffset);

            return geometry;
        }

        function createInnerPrismGeometry(size, length, radius, bevel) {
            const shape = new THREE.Shape();
            const R = size;
            const r = radius;

            const angleStart = -Math.PI / 2;
            const angleStep = Math.PI * 2 / 3;
            const dist = R - 2 * r;

            for (let i = 0; i < 3; i++) {
                const angle = angleStart + i * angleStep;
                const cx = dist * Math.cos(angle);
                const cy = dist * Math.sin(angle);
                shape.absarc(cx, cy, r, angle - Math.PI / 3, angle + Math.PI / 3, false);
            }
            shape.closePath();

            const extrudeSettings = {
                steps: 1,
                depth: length,
                bevelEnabled: true,
                bevelThickness: bevel,
                bevelSize: bevel,
                bevelSegments: 5
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            // Center along Z only
            geometry.translate(0, 0, -length / 2);
            return geometry;
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 14;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            raycaster.setFromCamera(mouse, camera);

            // Raycast recursively to hit meshes inside groups
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                let obj = intersects[0].object;

                // Traverse up to find the pixel group
                let targetGroup = null;
                if (obj.userData.parentGroup) {
                    targetGroup = obj.userData.parentGroup;
                } else {
                    // Fallback traverse
                    let curr = obj;
                    while (curr.parent && !pixels.includes(curr)) {
                        curr = curr.parent;
                    }
                    if (pixels.includes(curr)) targetGroup = curr;
                }

                if (targetGroup && !targetGroup.userData.isAnimating) {
                    targetGroup.userData.isAnimating = true;
                    targetGroup.userData.targetRotationX += (Math.PI * 2) / 3;
                }
            }

            pixels.forEach(group => {
                if (group.userData.isAnimating) {
                    // Smooth rotation using linear interpolation for consistent speed, 
                    // or lerp for ease-out. Let's use ease-out for premium feel.
                    const speed = 0.1;
                    const diff = group.userData.targetRotationX - group.rotation.x;

                    if (Math.abs(diff) < 0.005) {
                        group.rotation.x = group.userData.targetRotationX;
                        group.userData.isAnimating = false;
                    } else {
                        group.rotation.x += diff * speed;
                    }
                }
            });

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>

</html>