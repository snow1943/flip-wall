<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>多彩立方体舞台</title>
  <style>
    :root {
      --bg-start: #0a53c8;
      --bg-end: #0b7de4;
      --ink: #071839;
      --text: #dff1ff;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "PingFang SC", "Microsoft YaHei", "Noto Sans SC", sans-serif;
      background: linear-gradient(180deg, var(--bg-start), var(--bg-end));
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .hud {
      position: fixed;
      left: 16px;
      top: 14px;
      z-index: 3;
      color: var(--text);
      background: rgba(5, 22, 56, 0.32);
      border: 1px solid rgba(217, 240, 255, 0.28);
      border-radius: 10px;
      padding: 10px 12px;
      backdrop-filter: blur(3px);
      pointer-events: none;
      line-height: 1.45;
      font-size: 13px;
      max-width: min(80vw, 320px);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }
  </style>
</head>
<body>
  <div class="hud">
    多彩立方体舞台（Three.js）<br />
    左键旋转 · 滚轮缩放 · 右键平移
  </div>

  <script src="./vendor/three-r128.min.js"></script>
  <script src="./vendor/OrbitControls-r128.js"></script>
  <script>
    if (typeof THREE === "undefined") {
      const msg = document.createElement("div");
      msg.style.cssText = "position:fixed;left:16px;bottom:16px;z-index:10;background:rgba(0,0,0,.65);color:#fff;padding:10px 12px;border-radius:8px;font:13px/1.5 sans-serif;";
      msg.textContent = "Three.js 加载失败，请检查网络后刷新。";
      document.body.appendChild(msg);
      throw new Error("Three.js failed to load");
    }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0c62d8);
    scene.fog = new THREE.Fog(0x0c62d8, 30, 60);

    const camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 5.1, 16.2);
    camera.lookAt(0, 2.7, -0.6);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.16;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const controls = THREE.OrbitControls
      ? new THREE.OrbitControls(camera, renderer.domElement)
      : null;
    if (controls) {
      controls.enableDamping = true;
      controls.target.set(0, 2.7, -0.6);
      controls.minDistance = 11;
      controls.maxDistance = 22;
      controls.maxPolarAngle = Math.PI * 0.47;
      controls.minPolarAngle = Math.PI * 0.2;
    } else {
      const msg = document.createElement("div");
      msg.style.cssText = "position:fixed;left:16px;bottom:16px;z-index:10;background:rgba(0,0,0,.65);color:#fff;padding:10px 12px;border-radius:8px;font:13px/1.5 sans-serif;";
      msg.textContent = "OrbitControls 加载失败，已切换为无交互模式。";
      document.body.appendChild(msg);
    }

    const hemi = new THREE.HemisphereLight(0xa8daff, 0x16366d, 0.56);
    scene.add(hemi);

    const keyLight = new THREE.DirectionalLight(0xffffff, 1.05);
    keyLight.position.set(2, 11, 9);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.set(2048, 2048);
    keyLight.shadow.camera.left = -15;
    keyLight.shadow.camera.right = 15;
    keyLight.shadow.camera.top = 15;
    keyLight.shadow.camera.bottom = -15;
    scene.add(keyLight);

    const fillLight = new THREE.DirectionalLight(0x74b9ff, 0.44);
    fillLight.position.set(-12, 6, -6);
    scene.add(fillLight);

    const pinkLight = new THREE.PointLight(0xff4fd0, 1.35, 24);
    pinkLight.position.set(4.8, 5, 2);
    scene.add(pinkLight);

    const cyanLight = new THREE.PointLight(0x2fd7ff, 1.12, 20);
    cyanLight.position.set(-5.5, 4, -1.2);
    scene.add(cyanLight);

    const warmLight = new THREE.PointLight(0xffb378, 0.95, 22);
    warmLight.position.set(0, 3.5, -3.8);
    scene.add(warmLight);

    const backWall = new THREE.Mesh(
      new THREE.PlaneGeometry(20, 10),
      new THREE.MeshStandardMaterial({
        color: 0x0c67d9,
        roughness: 0.62,
        metalness: 0.12
      })
    );
    backWall.position.set(0, 5, -6.8);
    scene.add(backWall);

    const panelLineMaterial = new THREE.LineBasicMaterial({ color: 0x071735, transparent: true, opacity: 0.76 });
    for (let i = -8; i <= 8; i += 2) {
      const points = [new THREE.Vector3(i, 0, -6.79), new THREE.Vector3(i, 10, -6.79)];
      const geo = new THREE.BufferGeometry().setFromPoints(points);
      scene.add(new THREE.Line(geo, panelLineMaterial));
    }
    const panelHorizontals = [0, 2.75, 5.5, 10];
    for (let i = 0; i < panelHorizontals.length; i += 1) {
      const y = panelHorizontals[i];
      const geo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-10, y, -6.79),
        new THREE.Vector3(10, y, -6.79)
      ]);
      scene.add(new THREE.Line(geo, panelLineMaterial));
    }

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(20, 26),
      new THREE.MeshPhysicalMaterial({
        color: 0x2a6199,
        roughness: 0.22,
        metalness: 0.78,
        clearcoat: 0.4,
        clearcoatRoughness: 0.18
      })
    );
    floor.rotation.x = -Math.PI * 0.5;
    floor.position.z = 2.8;
    floor.receiveShadow = true;
    scene.add(floor);

    const runway = new THREE.Mesh(
      new THREE.PlaneGeometry(5.8, 20),
      new THREE.MeshPhysicalMaterial({
        color: 0x21508b,
        roughness: 0.08,
        metalness: 0.92,
        clearcoat: 0.8,
        clearcoatRoughness: 0.08
      })
    );
    runway.rotation.x = -Math.PI * 0.5;
    runway.position.set(0, 0.012, 5.7);
    scene.add(runway);

    const gridMaterial = new THREE.LineBasicMaterial({ color: 0x0b203f, transparent: true, opacity: 0.72 });
    const gridGroup = new THREE.Group();
    for (let x = -9; x <= 9; x += 2) {
      const g = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(x, 0.02, -8.6),
        new THREE.Vector3(x, 0.02, 12)
      ]);
      gridGroup.add(new THREE.Line(g, gridMaterial));
    }
    for (let z = -8; z <= 12; z += 2) {
      const g = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-9, 0.02, z),
        new THREE.Vector3(9, 0.02, z)
      ]);
      gridGroup.add(new THREE.Line(g, gridMaterial));
    }
    scene.add(gridGroup);

    const pillarConfigs = [
      { x: -7.1, z: 1.55, w: 2.35, h: 3.05, d: 2.2, top: "#bfffd0", bottom: "#76d7a2" },
      { x: -7.1, z: -0.95, w: 2.25, h: 2.2, d: 2.05, top: "#86ebff", bottom: "#1fb8ef", baseY: 3.05 },
      { x: -4.55, z: -0.55, w: 2.55, h: 5.85, d: 2.35, top: "#d8b4ff", bottom: "#7f88ff" },
      { x: -1.65, z: -1.25, w: 2.75, h: 4.2, d: 2.3, top: "#ff98d7", bottom: "#ff1f8d" },
      { x: 1.95, z: -1.25, w: 2.75, h: 4.2, d: 2.3, top: "#ffc488", bottom: "#ff7865" },
      { x: 4.75, z: -0.35, w: 2.55, h: 5.95, d: 2.35, top: "#ff82e6", bottom: "#da5bff" },
      { x: 6.85, z: 1.2, w: 2.65, h: 2.75, d: 2.2, top: "#c19dff", bottom: "#83b3ff" },
      { x: 6.25, z: 3.5, w: 2.55, h: 3.05, d: 2.2, top: "#ffb0d1", bottom: "#ff7eb4" }
    ];

    const pillars = [];
    const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x020913, transparent: true, opacity: 1.0 });
    const topEdgeMaterial = new THREE.LineBasicMaterial({ color: 0x01070f, transparent: true, opacity: 1.0 });
    const glowEdgeMaterial = new THREE.LineBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.36,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    function makeGradientTexture(topColor, bottomColor, seed) {
      const canvas = document.createElement("canvas");
      canvas.width = 256;
      canvas.height = 512;
      const ctx = canvas.getContext("2d");
      const top = new THREE.Color(topColor);
      const bottom = new THREE.Color(bottomColor);
      const peak = top.clone().offsetHSL(0, 0.04, 0.12);
      const mid = top.clone().lerp(bottom, 0.4);
      const low = bottom.clone().offsetHSL(0, 0.06, -0.08);
      let s = seed * 1103515245 + 12345;
      const rnd = () => {
        s = (s * 1664525 + 1013904223) >>> 0;
        return s / 4294967296;
      };

      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, peak.getStyle());
      gradient.addColorStop(0.5, mid.getStyle());
      gradient.addColorStop(1, low.getStyle());
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let i = 0; i < 9; i += 1) {
        const cx = canvas.width * (0.08 + rnd() * 0.84);
        const cy = canvas.height * (0.06 + rnd() * 0.88);
        const r = canvas.width * (0.18 + rnd() * 0.48);
        const mixed = top.clone().lerp(bottom, rnd() * 0.9).offsetHSL((rnd() - 0.5) * 0.08, 0.12, (rnd() - 0.5) * 0.22);
        const blob = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        blob.addColorStop(0, mixed.getStyle());
        blob.addColorStop(1, "rgba(255,255,255,0)");
        ctx.globalAlpha = 0.13 + rnd() * 0.17;
        ctx.fillStyle = blob;
        ctx.fillRect(cx - r, cy - r, r * 2, r * 2);
      }

      ctx.globalCompositeOperation = "multiply";
      for (let i = 0; i < 3; i += 1) {
        const cx = canvas.width * (0.1 + rnd() * 0.8);
        const cy = canvas.height * (0.25 + rnd() * 0.7);
        const r = canvas.width * (0.22 + rnd() * 0.3);
        const shade = bottom.clone().offsetHSL(0, -0.12, -0.2);
        const shadow = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        shadow.addColorStop(0, shade.getStyle());
        shadow.addColorStop(1, "rgba(0,0,0,0)");
        ctx.globalAlpha = 0.09 + rnd() * 0.08;
        ctx.fillStyle = shadow;
        ctx.fillRect(cx - r, cy - r, r * 2, r * 2);
      }
      ctx.globalCompositeOperation = "source-over";

      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height * 0.16);

      ctx.globalAlpha = 0.2;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(canvas.width * 0.1, 0, canvas.width * 0.085, canvas.height);
      ctx.fillRect(canvas.width * 0.68, 0, canvas.width * 0.05, canvas.height);

      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#121e42";
      ctx.fillRect(0, 0, canvas.width * 0.05, canvas.height);
      ctx.fillRect(canvas.width * 0.95, 0, canvas.width * 0.05, canvas.height);

      ctx.globalAlpha = 0.06;
      for (let i = 0; i < 120; i += 1) {
        const x = Math.floor(rnd() * canvas.width);
        const y = Math.floor(rnd() * canvas.height);
        const size = 1 + Math.floor(rnd() * 2);
        ctx.fillStyle = rnd() > 0.45 ? "#ffffff" : "#2c3b6a";
        ctx.fillRect(x, y, size, size);
      }

      const texture = new THREE.CanvasTexture(canvas);
      texture.encoding = THREE.sRGBEncoding;
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      return texture;
    }

    function addPillar(cfg, index) {
      const texture = makeGradientTexture(cfg.top, cfg.bottom, index + 1);
      const sideMaterial = new THREE.MeshPhongMaterial({
        map: texture,
        transparent: true,
        opacity: 0.97,
        shininess: 90,
        specular: new THREE.Color("#f3fbff"),
        emissive: new THREE.Color(cfg.bottom),
        emissiveIntensity: 0.24
      });
      const topMaterial = new THREE.MeshPhongMaterial({
        color: new THREE.Color(cfg.top).offsetHSL(0.0, -0.05, 0.1),
        transparent: true,
        opacity: 0.95,
        shininess: 80,
        specular: new THREE.Color("#e2f5ff")
      });
      const bottomMaterial = new THREE.MeshBasicMaterial({
        color: 0x154687,
        transparent: true,
        opacity: 0.4
      });
      const materials = [sideMaterial, sideMaterial, topMaterial, bottomMaterial, sideMaterial, sideMaterial];

      const geo = new THREE.BoxGeometry(cfg.w, cfg.h, cfg.d);
      const mesh = new THREE.Mesh(geo, materials);
      const y = (cfg.baseY || 0) + cfg.h * 0.5;
      mesh.position.set(cfg.x, y, cfg.z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);

      const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geo), edgeMaterial);
      edges.position.copy(mesh.position);
      scene.add(edges);

      const glowEdges = new THREE.LineSegments(new THREE.EdgesGeometry(geo), glowEdgeMaterial.clone());
      glowEdges.scale.set(1.006, 1.006, 1.006);
      glowEdges.position.copy(mesh.position);
      scene.add(glowEdges);

      const outlineMesh = new THREE.Mesh(
        geo.clone(),
        new THREE.MeshBasicMaterial({
          color: 0x020913,
          side: THREE.BackSide,
          transparent: true,
          opacity: 0.95
        })
      );
      outlineMesh.scale.set(1.012, 1.012, 1.012);
      outlineMesh.position.copy(mesh.position);
      scene.add(outlineMesh);

      const hw = cfg.w * 0.5;
      const hd = cfg.d * 0.5;
      const topY = (cfg.baseY || 0) + cfg.h + 0.005;
      const topLoop = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-hw, topY, -hd),
        new THREE.Vector3(hw, topY, -hd),
        new THREE.Vector3(hw, topY, hd),
        new THREE.Vector3(-hw, topY, hd)
      ]);
      const topBorder = new THREE.LineLoop(topLoop, topEdgeMaterial);
      topBorder.position.set(cfg.x, 0, cfg.z);
      scene.add(topBorder);

      const topGlow = new THREE.LineLoop(topLoop.clone(), glowEdgeMaterial.clone());
      topGlow.position.set(cfg.x, 0, cfg.z);
      scene.add(topGlow);

      pillars.push({
        sideMaterial,
        glowEdgesMaterial: glowEdges.material,
        topGlowMaterial: topGlow.material,
        phase: index * 0.67
      });
    }

    for (let i = 0; i < pillarConfigs.length; i += 1) addPillar(pillarConfigs[i], i);

    const stageFrameMaterial = new THREE.LineBasicMaterial({ color: 0x031026, transparent: true, opacity: 0.95 });
    const framePoints = [
      new THREE.Vector3(-9, 0.04, -8.6),
      new THREE.Vector3(9, 0.04, -8.6),
      new THREE.Vector3(9, 0.04, 12),
      new THREE.Vector3(-9, 0.04, 12),
      new THREE.Vector3(-9, 0.04, -8.6)
    ];
    const frameGeo = new THREE.BufferGeometry().setFromPoints(framePoints);
    scene.add(new THREE.Line(frameGeo, stageFrameMaterial));

    const clock = new THREE.Clock();
    renderer.setAnimationLoop(() => {
      const t = clock.getElapsedTime();
      pinkLight.intensity = 1.3 + Math.sin(t * 0.55) * 0.035;
      cyanLight.intensity = 1.08 + Math.cos(t * 0.52) * 0.03;
      for (let i = 0; i < pillars.length; i += 1) {
        const p = pillars[i];
        p.glowEdgesMaterial.opacity = 0.32 + Math.sin(t * 0.9 + p.phase) * 0.06;
        p.topGlowMaterial.opacity = 0.42 + Math.cos(t * 0.85 + p.phase) * 0.06;
      }
      if (controls) controls.update();
      renderer.render(scene, camera);
    });

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });
  </script>
</body>
</html>
